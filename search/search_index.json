{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to the flyfield Documentation","text":"<p>This documentation supports users and developers working with flyfield, a Python tool to automate white-box PDF form field extraction, filling, and data capture.</p>"},{"location":"index.html#tutorials","title":"Tutorials","text":"<ul> <li>Quick Start Guide   Fast-track for new users to start extracting and filling forms.</li> <li>Worked Example   Step-by-step walkthrough using a real-world tax form.</li> </ul>"},{"location":"index.html#how-to-guides","title":"How-To Guides","text":"<ul> <li>Installation Guide   Setup instructions and troubleshooting.</li> <li>Usage and CLI Reference   Detailed command-line options and workflows.</li> <li>FAQ   Frequently asked questions and common troubleshooting.</li> </ul>"},{"location":"index.html#reference","title":"Reference","text":"<ul> <li>Configuration and Constants   Customization and advanced settings.</li> <li>API Documentation   Programmatic interface for developers.</li> </ul>"},{"location":"index.html#concepts-and-explanations","title":"Concepts and Explanations","text":"<ul> <li>Introduction   Overview and purpose of flyfield.</li> <li>Process Explanation   Detailed breakdown of internal workings.</li> <li>Glossary   Definitions of key terms used throughout the docs.</li> </ul> <p>Notes</p> <ul> <li>The tool only supports vector PDFs with white boxes, not scanned rasterized PDFs.</li> <li>Refer to tutorials and how-to guides first before diving into reference or concepts for a smoother learning curve.</li> </ul> <p>Start your journey by exploring the Quick Start Guide.</p>"},{"location":"api.html","title":"API Documentation for flyfield","text":"<p>This documentation provides a detailed reference to the flyfield Python API for programmatically working with PDF forms that use white box placeholders.</p> <p>Overview</p> <p>The flyfield API automates workflows including:</p> <ul> <li>Extracting white box placeholders from vector PDFs</li> <li>Filtering, deduplicating, and grouping detected regions into logical fields</li> <li>Generating interactive AcroForm fields in PDFs programmatically</li> <li>Filling form fields with data from CSV files</li> <li>Capturing data back from filled PDFs into CSV</li> </ul> <p>The API is modular and can be imported into Python projects, offering programmable control beyond the CLI.</p>"},{"location":"api.html#key-modules-and-functions","title":"Key Modules and Functions","text":""},{"location":"api.html#1-extraction-extractpy","title":"1. Extraction (<code>extract.py</code>)","text":"<ul> <li><code>extract_boxes(pdf_path: str) -&gt; List[dict]</code> Extracts all white boxes from a PDF that match <code>config.TARGET_COLOUR</code> (pure white by default).<ul> <li>Converts coordinates to the standard bottom-left PDF system.</li> <li>Returns a list of box dictionaries with metadata such as <code>page_num</code>, <code>bbox</code>, <code>chars</code>, and <code>field_type</code>.</li> </ul> </li> <li><code>filter_boxes(page: fitz.Page, boxes: List[dict]) -&gt; List[dict]</code> Filters raw boxes by:<ul> <li>Size (<code>MIN_BOX_HEIGHT</code>, <code>MAX_BOX_HEIGHT</code>)</li> <li>Allowed text (<code>utils.allowed_text</code>)</li> <li>Retains only candidate placeholders.</li> </ul> </li> <li><code>remove_duplicates(boxes: List[dict]) -&gt; List[dict]</code> Removes duplicates based on rounded coordinates on each page.</li> <li><code>sort_boxes(boxes: List[dict], decimal_places: int=0) -&gt; List[dict]</code> Sorts results top-to-bottom, then left-to-right.</li> <li> <p><code>process_boxes(pdf_path: str, csv_path: str) -&gt; Dict[int, List[dict]]</code> Full extraction pipeline:</p> </li> <li> <p>Extract \u2192 Filter \u2192 Deduplicate \u2192 Sort</p> </li> <li>Compute layout fields (<code>calculate_layout_fields</code>)</li> <li>Assign numeric block types (<code>assign_numeric_blocks</code>)</li> <li>Save annotated results to CSV Returns a dictionary keyed by <code>page_num</code>.</li> </ul>"},{"location":"api.html#2-layout-layoutpy","title":"2. Layout (<code>layout.py</code>)","text":"<ul> <li><code>calculate_layout_fields(boxes: List[dict]) -&gt; Dict[int, List[dict]]</code> Annotates box rows with:<ul> <li>IDs, line numbers, block grouping</li> <li>Block length/width</li> <li>Concatenated <code>block_fill</code> text or formatted money values</li> </ul> </li> <li><code>assign_numeric_blocks(page_dict: Dict[int, List[dict]]) -&gt; Dict[int, List[dict]]</code> Merges sequential numeric blocks (e.g. <code>### ### ##</code> patterns) into currency fields.<ul> <li>Assigns <code>\"Currency\"</code> or <code>\"CurrencyDecimal\"</code> where applicable.</li> </ul> </li> </ul>"},{"location":"api.html#3-csv-io-io_utilspy","title":"3. CSV I/O (<code>io_utils.py</code>)","text":"<ul> <li><code>load_boxes_from_csv(csv_path: str) -&gt; Dict[int, List[dict]]</code> Reads CSV data into a page dictionary for further processing.</li> <li><code>write_csv(data, csv_path: str) -&gt; None</code> Writes box/page data back to CSV in canonical format.<ul> <li>Ensures only one <code>fill</code> column is stored (<code>block_fill</code> or fallback <code>fill</code>).</li> </ul> </li> <li><code>read_csv_rows(filename: str) -&gt; List[dict]</code> Reads CSV into dictionaries, parsing numeric fills with <code>parse_money_space</code> or <code>parse_implied_decimal</code>.</li> <li><code>save_pdf_form_data_to_csv(pdf_path: str, csv_path: str, boxes: dict=None) -&gt; None</code> Captures filled AcroForm values from a PDF and writes them to CSV.<ul> <li>Applies <code>NUMERIC_FIELD_TYPES</code> parsing rules.</li> <li>Uppercases strings where applicable.</li> </ul> </li> </ul>"},{"location":"api.html#4-markup-and-field-scripts-markup_and_fieldspy","title":"4. Markup and Field Scripts (<code>markup_and_fields.py</code>)","text":"<ul> <li><code>markup_pdf(pdf_path: str, page_dict: Dict[int,List[dict]], output_pdf: str, mark_color=(0,0,1)) -&gt; None</code> Creates a debug PDF marking detected fields with circles and rotated field codes.</li> <li><code>generate_form_fields_script(csv_path: str, input_pdf: str, output_pdf: str, script_path: str) -&gt; str</code> Generates a standalone Python script that adds AcroForm fields to a given PDF, based on detected CSV data.</li> <li><code>run_standalone_script(script_path: str) -&gt; None</code> Executes the generated script in a subprocess to apply fields.</li> <li><code>run_fill_pdf_fields(csv_path: str, output_pdf: str, template_pdf: str, generator_script: str, boxes: dict=None) -&gt; None</code> Generates and runs a filler script that populates an interactive PDF with values from a CSV.<ul> <li>Supports monetary formatting via <code>format_money_space</code>.</li> <li>Supports normalization of Currency/CurrencyDecimal values by stripping non-digits.</li> </ul> </li> </ul>"},{"location":"api.html#5-utilities-utilspy","title":"5. Utilities (<code>utils.py</code>)","text":"<ul> <li><code>add_suffix_to_filename(filename: str, suffix: str) -&gt; str</code> Adds a suffix before the file extension.</li> <li><code>colour_match(color: Tuple, target_color=(1,1,1), tol=1e-3) -&gt; bool</code> Compares normalized RGB colors with tolerance.</li> <li><code>int_to_rgb(color_int: int) -&gt; Tuple[float,float,float]</code> Converts an integer 0xRRGGBB color to normalized floats.</li> <li><code>clean_fill_string(line_text: str) -&gt; str</code> Removes single spaces but preserves aligned spacing.</li> <li><code>allowed_text(text: str, field_type: Optional[str]) -&gt; Tuple[bool, Optional[str]]</code> Checks whether a string value inside a field is allowed (filters out pre-printed text).</li> <li><code>format_money_space(amount: Union[float,int], decimal=True) -&gt; str</code> Formats numeric values with:<ul> <li>Space as thousand separator</li> <li>Space as decimal marker (if decimal=True)</li> </ul> </li> <li><code>parse_money_space(s: str, decimal=True) -&gt; Union[int,float]</code> Parses strings formatted above back into numbers.</li> <li><code>parse_implied_decimal(s: str) -&gt; float</code> Parses numbers treating the last two digits as cents.</li> <li><code>parse_pages(pages_str: str) -&gt; List[int]</code> Parses <code>\"1,3-5,7\"</code> into <code>[1,3,4,5,7]</code>.</li> <li><code>conditional_merge_list(main_list, ref_list, match_key, keys_to_merge)</code> Merges keys from a reference list into a main list when values of <code>match_key</code> match.</li> </ul>"},{"location":"api.html#field-data-structure","title":"Field Data Structure","text":"<p>flyfield represents form fields as dictionaries (not classes):</p> Key Type Description <code>code</code> str Unique identifier (<code>page-line-block</code> naming scheme) <code>page_num</code> int PDF page number (1-based) <code>x0,y0,x1,y1</code> float Bounding box coordinates (PDF bottom-left system) <code>left, right</code> float Rounded left/right coordinates <code>top, bottom</code> float Rounded positions <code>line</code> int Line number on page <code>block</code> int Block number within line <code>block_length</code> int Number of boxes in block <code>block_width</code> float Width of block in points <code>field_type</code> str One of <code>\"Dollars\"</code>, <code>\"DollarCents\"</code>, <code>\"Currency\"</code>, etc. <code>chars</code> str Non-black overlay text extracted <code>fill</code> str/num Overlay text (user values, may be pre-filled) <code>block_fill</code> str/num Aggregated/normalized block fill"},{"location":"api.html#example-usage","title":"Example Usage","text":"<pre><code>from flyfield.extract import process_boxes\nfrom flyfield.io_utils import save_pdf_form_data_to_csv\nfrom flyfield.markup_and_fields import  run_fill_pdf_fields\nfrom flyfield import config\n\n# Process boxes and save CSV\npage_dict = process_boxes(\"example.pdf\", \"example.csv\")\n\n# Generate a markup PDF\nfrom flyfield.markup_and_fields import markup_pdf\nmarkup_pdf(\"example.pdf\", page_dict, \"example-markup.pdf\")\n\n# Fill fields with values from another CSV\nrun_fill_pdf_fields(\"example.csv\",\n                    \"example-filled.pdf\",\n                    \"example-fields.pdf\",\n                    \"example-filler.py\",\n                    page_dict)\n\n# Capture back to CSV after filling\nsave_pdf_form_data_to_csv(\"example-filled.pdf\", \"example-capture.csv\", page_dict)\n</code></pre> <p>Info</p> <ul> <li>flyfield depends on PyMuPDF (<code>fitz</code>) for box extraction and markup, and PyPDFForm for form field creation and filling.</li> <li>Monetary/Currency parsing is opinionated.</li> <li>All generated scripts (<code>-field-generator.py</code>, <code>-filler.py</code>) are standalone and reusable in case of workflow adjustments.</li> <li>Debug logging (<code>--debug</code>) outputs stepwise CSVs for troubleshooting.</li> </ul>"},{"location":"api.html#further-resources","title":"Further Resources","text":"<ul> <li>Configuration Reference \u2014 adjustable thresholds and suffixes</li> <li>Developer Guide \u2014 core architecture and extension points</li> <li>Worked Example \u2014 end-to-end workflow with CSV integration</li> </ul> <p>Automatic documentation from sources by mkdocstrings.</p>"},{"location":"api.html#core-modules","title":"Core Modules","text":""},{"location":"api.html#flyfield.extract","title":"<code>flyfield.extract</code>","text":"<p>Extraction functions for PDF processing.</p> <p>Provides methods to extract PDF box data and text.</p>"},{"location":"api.html#flyfield.extract.extract_boxes","title":"<code>extract_boxes(pdf_path)</code>","text":"<p>Extract filled rectangles (boxes) from a PDF matching a target color.</p> <p>Parameters:</p> Name Type Description Default <code>pdf_path</code> <code>str</code> <p>Path to the input PDF file.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>list of dict: Each dict details box coordinates (PDF coordinates, origin bottom-left),</p> <code>List[Dict]</code> <p>page number, and other metadata for detected boxes.</p> Notes <p>Converts PyMuPDF coordinates (origin top-left) to PDF standard bottom-left origin. Only boxes filled with the target color are extracted.</p> Source code in <code>flyfield/extract.py</code> <pre><code>def extract_boxes(pdf_path: str) -&gt; List[Dict]:\n    \"\"\"\n    Extract filled rectangles (boxes) from a PDF matching a target color.\n\n    Args:\n        pdf_path (str): Path to the input PDF file.\n\n    Returns:\n        list of dict: Each dict details box coordinates (PDF coordinates, origin bottom-left),\n        page number, and other metadata for detected boxes.\n\n    Notes:\n        Converts PyMuPDF coordinates (origin top-left) to PDF standard bottom-left origin.\n        Only boxes filled with the target color are extracted.\n    \"\"\"\n    boxes = []\n    try:\n        with fitz.open(pdf_path) as doc:\n            for page_num in range(1, len(doc) + 1):\n                try:\n                    page = doc[page_num - 1]\n                except IndexError:\n                    logger.warning(f\"Page {page_num} not found in document.\")\n                    continue\n                page_height = page.rect.height\n                for drawing in page.get_drawings():\n                    rect = drawing.get(\"rect\")\n                    fill_color = drawing.get(\"fill\")\n                    if rect and colour_match(fill_color, target_color=TARGET_COLOUR):\n                        # Convert PyMuPDF page coordinates (origin top-left)\n                        # to PDF coordinate system (origin bottom-left)\n\n                        pdf_y0 = page_height - rect.y1\n                        pdf_y1 = page_height - rect.y0\n                        boxes.append(\n                            {\n                                \"page_num\": page_num,\n                                \"x0\": rect.x0,\n                                \"y0\": pdf_y0,\n                                \"x1\": rect.x1,\n                                \"y1\": pdf_y1,\n                                \"left\": round(rect.x0, 2),\n                                \"bottom\": round(pdf_y0, 2),\n                                \"right\": round(rect.x1, 2),\n                                \"top\": round(pdf_y1, 2),\n                                \"chars\": \"\",\n                                \"field_type\": None,\n                            }\n                        )\n    except Exception as e:\n        logger.error(f\"Could not open PDF file {pdf_path}: {e}\")\n    return boxes\n</code></pre>"},{"location":"api.html#flyfield.extract.filter_boxes","title":"<code>filter_boxes(page, boxes)</code>","text":"<p>Filter a list of boxes on a PDF page based on height and allowed text.</p> <p>Parameters:</p> Name Type Description Default <code>page</code> <code>Page</code> <p>PyMuPDF page object.</p> required <code>boxes</code> <code>list of dict</code> <p>List of box dictionaries to filter.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>list of dict: Filtered boxes that meet size and allowed text criteria.</p> Notes <p>Excludes boxes outside valid height ranges or with disallowed text.</p> Source code in <code>flyfield/extract.py</code> <pre><code>def filter_boxes(page: fitz.Page, boxes: List[Dict]) -&gt; List[Dict]:\n    \"\"\"\n    Filter a list of boxes on a PDF page based on height and allowed text.\n\n    Args:\n        page (fitz.Page): PyMuPDF page object.\n        boxes (list of dict): List of box dictionaries to filter.\n\n    Returns:\n        list of dict: Filtered boxes that meet size and allowed text criteria.\n\n    Notes:\n        Excludes boxes outside valid height ranges or with disallowed text.\n    \"\"\"\n    filtered = []\n    page_height = page.rect.height\n    black = (0, 0, 0)  # RGB for black text matching\n\n    for box in boxes:\n        height = box.get(\"y1\", 0) - box.get(\"y0\", 0)\n        if height &lt; MIN_BOX_HEIGHT or height &gt; MAX_BOX_HEIGHT:\n            continue\n        # Convert box coordinates to PyMuPDF's coordinate system for clipping\n\n        pymupdf_y0 = page_height - box[\"y1\"]\n        pymupdf_y1 = page_height - box[\"y0\"]\n        clip_rect = fitz.Rect(box[\"x0\"], pymupdf_y0, box[\"x1\"], pymupdf_y1)\n\n        text_dict = page.get_text(\"dict\", clip=clip_rect)\n\n        black_text_parts = []\n        non_black_text_parts = []\n\n        for block in text_dict.get(\"blocks\", []):\n            for line in block.get(\"lines\", []):\n                for span in line.get(\"spans\", []):\n                    span_text = span.get(\"text\", \"\").strip()\n                    if not span_text:\n                        continue\n                    span_color = span.get(\"color\")\n                    rgb = None\n                    if span_color is not None:\n                        if isinstance(span_color, int):\n                            rgb = int_to_rgb(span_color)\n                        elif isinstance(span_color, str):\n                            try:\n                                rgb = fitz.utils.getColor(span_color)\n                            except Exception:\n                                rgb = None\n                    if rgb and colour_match(rgb, target_color=black):\n                        black_text_parts.append(span_text)\n                    else:\n                        non_black_text_parts.append(span_text)\n        fill_text = \"\".join(black_text_parts)\n        box_text = \"\".join(non_black_text_parts)\n\n        allowed, detected_field_type = allowed_text(\n            box_text, field_type=box.get(\"field_type\")\n        )\n        if box_text and not allowed:\n            continue\n        box[\"field_type\"] = detected_field_type\n        box[\"chars\"] = box_text\n        box[\"fill\"] = fill_text\n        filtered.append(box)\n    return filtered\n</code></pre>"},{"location":"api.html#flyfield.extract.remove_duplicates","title":"<code>remove_duplicates(boxes)</code>","text":"<p>Remove duplicate boxes on the same page based on rounded coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>list of dict</code> <p>List of box dictionaries.</p> required <p>Returns:</p> Type Description <code>List[Dict]</code> <p>list of dict: Boxes with duplicates removed.</p> Source code in <code>flyfield/extract.py</code> <pre><code>def remove_duplicates(boxes: List[Dict]) -&gt; List[Dict]:\n    \"\"\"\n    Remove duplicate boxes on the same page based on rounded coordinates.\n\n    Args:\n        boxes (list of dict): List of box dictionaries.\n\n    Returns:\n        list of dict: Boxes with duplicates removed.\n    \"\"\"\n    page_groups = defaultdict(list)\n    for box in boxes:\n        page_groups[box[\"page_num\"]].append(box)\n    cleaned = []\n    for _page_num, page_boxes in page_groups.items():\n        seen = set()\n        for box in page_boxes:\n            key = (\n                round(box[\"x0\"], 3),\n                round(box[\"y0\"], 3),\n                round(box[\"x1\"], 3),\n                round(box[\"y1\"], 3),\n            )\n            if key not in seen:\n                seen.add(key)\n                cleaned.append(box)\n    return cleaned\n</code></pre>"},{"location":"api.html#flyfield.extract.sort_boxes","title":"<code>sort_boxes(boxes, decimal_places=0)</code>","text":"<p>Sort boxes by page number, top-to-bottom (descending), then left-to-right.</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>list of dict</code> <p>List of boxes to sort.</p> required <code>decimal_places</code> <code>int</code> <p>Precision for vertical grouping (bottom coordinate rounding).</p> <code>0</code> <p>Returns:</p> Type Description <code>List[Dict]</code> <p>list of dict: Sorted boxes.</p> Source code in <code>flyfield/extract.py</code> <pre><code>def sort_boxes(boxes: List[Dict], decimal_places: int = 0) -&gt; List[Dict]:\n    \"\"\"\n    Sort boxes by page number, top-to-bottom (descending), then left-to-right.\n\n    Args:\n        boxes (list of dict): List of boxes to sort.\n        decimal_places (int): Precision for vertical grouping (bottom coordinate rounding).\n\n    Returns:\n        list of dict: Sorted boxes.\n    \"\"\"\n    return sorted(\n        boxes,\n        key=lambda b: (b[\"page_num\"], -round(b[\"bottom\"], decimal_places), b[\"left\"]),\n    )\n</code></pre>"},{"location":"api.html#flyfield.extract.process_boxes","title":"<code>process_boxes(pdf_path, csv_path)</code>","text":"<p>Full pipeline to extract, filter, deduplicate, sort, layout annotate, and save boxes from a PDF.</p> <p>Parameters:</p> Name Type Description Default <code>pdf_path</code> <code>str</code> <p>Path to input PDF file.</p> required <code>csv_path</code> <code>str</code> <p>Path to output CSV file for annotated box data.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[int, List[Dict]]</code> <p>Dictionary keyed by page number containing processed boxes with layout metadata.</p> Notes <ul> <li>Extract filled white boxes matching TARGET_COLOUR.</li> <li>Filter boxes by valid height and allowed text content.</li> <li>Remove duplicate boxes by coordinate proximity.</li> <li>Sort boxes by page, vertical then horizontal order.</li> <li>Compute layout fields such as IDs, block grouping, lines.</li> <li>Assign numeric block field types using heuristics.</li> <li>Write the full annotated box data to CSV.</li> </ul> Source code in <code>flyfield/extract.py</code> <pre><code>def process_boxes(pdf_path: str, csv_path: str) -&gt; Dict[int, List[Dict]]:\n    \"\"\"\n    Full pipeline to extract, filter, deduplicate, sort, layout annotate, and save boxes from a PDF.\n\n    Args:\n        pdf_path (str): Path to input PDF file.\n        csv_path (str): Path to output CSV file for annotated box data.\n\n    Returns:\n        dict: Dictionary keyed by page number containing processed boxes with layout metadata.\n\n    Notes:\n        - Extract filled white boxes matching TARGET_COLOUR.\n        - Filter boxes by valid height and allowed text content.\n        - Remove duplicate boxes by coordinate proximity.\n        - Sort boxes by page, vertical then horizontal order.\n        - Compute layout fields such as IDs, block grouping, lines.\n        - Assign numeric block field types using heuristics.\n        - Write the full annotated box data to CSV.\n    \"\"\"\n    logger.info(f\"Extracting boxes from PDF: {pdf_path}\")\n    boxes = extract_boxes(pdf_path)\n    logger.info(f\"Extracted {len(boxes)} white boxes.\")\n\n    try:\n        doc = fitz.open(pdf_path)\n    except Exception as e:\n        logger.error(f\"Error opening input PDF: {e}\")\n        return defaultdict(list)\n    if logger.isEnabledFor(logging.DEBUG):\n        write_csv(boxes, csv_path.replace(\".csv\", \"-extracted.csv\"))\n    filtered_boxes = []\n    for page_num in range(1, len(doc) + 1):\n        page_boxes = [p for p in boxes if p[\"page_num\"] == page_num]\n        filtered_boxes.extend(filter_boxes(doc[page_num - 1], page_boxes))\n    doc.close()\n\n    if logger.isEnabledFor(logging.DEBUG):\n        write_csv(filtered_boxes, csv_path.replace(\".csv\", \"-grouped.csv\"))\n    filtered_boxes = remove_duplicates(filtered_boxes)\n    filtered_boxes = sort_boxes(filtered_boxes, decimal_places=-1)\n\n    if logger.isEnabledFor(logging.DEBUG):\n        write_csv(filtered_boxes, csv_path.replace(\".csv\", \"-filtered.csv\"))\n    page_dict = calculate_layout_fields(filtered_boxes)\n\n    if logger.isEnabledFor(logging.DEBUG):\n        write_csv(filtered_boxes, csv_path.replace(\".csv\", \"-layout.csv\"))\n    page_dict = assign_numeric_blocks(page_dict)\n\n    write_csv(page_dict, csv_path)\n    return page_dict\n</code></pre>"},{"location":"api.html#flyfield.io_utils","title":"<code>flyfield.io_utils</code>","text":"<p>Utility functions for input/output operations.</p> <p>Includes CSV reading/writing and data transformation helpers.</p>"},{"location":"api.html#flyfield.io_utils.load_boxes_from_csv","title":"<code>load_boxes_from_csv(csv_path)</code>","text":"<p>Load boxes data from a CSV into a dictionary keyed by page number,</p> <p>applying the specified types to each column in the CSV.</p> <p>Parameters:</p> Name Type Description Default <code>csv_path</code> <code>str</code> <p>Path to the CSV file.</p> required <p>Returns:</p> Type Description <code>dict[int, list[dict]]</code> <p>dict[int, list[dict]]: Dictionary mapping page number (int)</p> <code>dict[int, list[dict]]</code> <p>to a list of box dictionaries with appropriately typed values.</p> Description <p>The CSV is expected to contain columns:</p> <ul> <li>page_num (int), id (int), x0 (float), y0 (float), x1 (float), y1 (float),</li> <li>left (float), top (float), right (float), bottom (float),</li> <li>height (float), width (float), pgap (float), gap (float),</li> <li>line (int), block (int), block_length (int), block_width (float),</li> <li>code (str), field_type (str), chars (str), fill (str)</li> </ul> <p>Each value from the CSV is converted from string to the appropriate type. Empty or missing values are converted to None for numeric types and empty string for strings. Conversion errors are caught and logged; original strings are kept in those cases.</p> Source code in <code>flyfield/io_utils.py</code> <pre><code>def load_boxes_from_csv(csv_path: str) -&gt; dict[int, list[dict]]:\n    \"\"\"\n    Load boxes data from a CSV into a dictionary keyed by page number,\n\n    applying the specified types to each column in the CSV.\n\n    Args:\n        csv_path (str): Path to the CSV file.\n\n    Returns:\n        dict[int, list[dict]]: Dictionary mapping page number (int)\n        to a list of box dictionaries with appropriately typed values.\n\n    Description:\n        The CSV is expected to contain columns:\n\n        - page_num (int), id (int), x0 (float), y0 (float), x1 (float), y1 (float),\n        - left (float), top (float), right (float), bottom (float),\n        - height (float), width (float), pgap (float), gap (float),\n        - line (int), block (int), block_length (int), block_width (float),\n        - code (str), field_type (str), chars (str), fill (str)\n\n        Each value from the CSV is converted from string to the appropriate type.\n        Empty or missing values are converted to None for numeric types and empty string for strings.\n        Conversion errors are caught and logged; original strings are kept in those cases.\n    \"\"\"\n    logger.info(f\"Reading blocks from CSV: {csv_path}\")\n    rows = read_csv_rows(csv_path)  # Should return list of dict[str, str]\n\n    def convert_value(value: str, to_type):\n        if value is None or value == \"\":\n            if to_type in (int, float):\n                return None\n            return \"\"\n        try:\n            return to_type(value)\n        except Exception as e:\n            logger.warning(f\"Failed to convert value '{value}' to {to_type}: {e}\")\n            return value  # fallback: keep original string\n\n    page_dict = defaultdict(list)\n    for row in rows:\n        typed_row = {\n            col: convert_value(row.get(col), col_type)\n            for col, col_type in COLUMN_TYPES.items()\n        }\n        if typed_row.get(\"page_num\") is not None:\n            page_dict[typed_row[\"page_num\"]].append(typed_row)\n    return page_dict\n</code></pre>"},{"location":"api.html#flyfield.io_utils.write_csv","title":"<code>write_csv(boxes_or_page_dict, csv_path)</code>","text":"<p>Write box data or page dictionary data to CSV file.</p> <p>Saves only one 'fill' column:     - Uses 'block_fill' if present,     - Otherwise falls back to original 'fill'.</p> <p>Parameters:</p> Name Type Description Default <code>boxes_or_page_dict</code> <code>list or dict</code> <p>List of box dicts or dict keyed by page containing lists of boxes.</p> required <code>csv_path</code> <code>str</code> <p>Output CSV file path.</p> required Source code in <code>flyfield/io_utils.py</code> <pre><code>def write_csv(\n    boxes_or_page_dict: Union[List[Dict], Dict[int, List[Dict]]], csv_path: str\n) -&gt; None:\n    \"\"\"\n    Write box data or page dictionary data to CSV file.\n\n    Saves only one 'fill' column:\n        - Uses 'block_fill' if present,\n        - Otherwise falls back to original 'fill'.\n\n    Args:\n        boxes_or_page_dict (list or dict): List of box dicts or dict keyed by page containing lists of boxes.\n        csv_path (str): Output CSV file path.\n    \"\"\"\n    if isinstance(boxes_or_page_dict, dict):\n        all_boxes = [\n            box\n            for boxes in boxes_or_page_dict.values()\n            if boxes is not None\n            for box in boxes\n        ]\n    else:\n        all_boxes = boxes_or_page_dict or []\n    try:\n        with open(csv_path, \"w\", newline=\"\", encoding=\"utf-8\") as f:\n            writer = csv.writer(f)\n            writer.writerow(CSV_HEADER)\n            for box in all_boxes:\n                height = round(box.get(\"y1\", 0) - box.get(\"y0\", 0), 1)\n                width = round(box.get(\"x1\", 0) - box.get(\"x0\", 0), 1)\n                fill_value = box.get(\"block_fill\")\n                if fill_value is None:\n                    fill_value = box.get(\"fill\", \"\")\n                field_type = box.get(\"field_type\")\n                # Convert monetary fill values back to float/int as appropriate\n\n                if (\n                    field_type in (\"Dollars\", \"DollarCents\", \"CurrencyDecimal\")\n                    and fill_value\n                ):\n                    decimal = field_type in (\"DollarCents\", \"CurrencyDecimal\")\n                    try:\n                        fill_value = parse_money_space(fill_value, decimal=decimal)\n                    except Exception as e:\n                        logger.warning(\n                            f\"Failed to parse money from fill_value '{fill_value}' for field_type '{field_type}': {e}\"\n                        )\n                row = [\n                    box.get(\"page_num\", \"\"),\n                    box.get(\"id\", \"\"),\n                    box.get(\"x0\", \"\"),\n                    box.get(\"y0\", \"\"),\n                    box.get(\"x1\", \"\"),\n                    box.get(\"y1\", \"\"),\n                    box.get(\"left\", \"\"),\n                    box.get(\"top\", \"\"),\n                    box.get(\"right\", \"\"),\n                    box.get(\"bottom\", \"\"),\n                    height,\n                    width,\n                    box.get(\"pgap\", \"\"),\n                    box.get(\"gap\", \"\"),\n                    box.get(\"line\", \"\"),\n                    box.get(\"block\", \"\"),\n                    box.get(\"block_length\", \"\"),\n                    box.get(\"block_width\", \"\"),\n                    box.get(\"code\", \"\"),\n                    box.get(\"field_type\", \"\"),\n                    box.get(\"chars\", \"\"),\n                    fill_value,\n                ]\n\n                writer.writerow(row)\n    except Exception as e:\n        logger.error(f\"Failed to write CSV {csv_path}: {e}\")\n</code></pre>"},{"location":"api.html#flyfield.io_utils.read_csv_rows","title":"<code>read_csv_rows(filename)</code>","text":"<p>Read CSV rows into a list, converting typed fields and normalizing monetary fills.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to CSV file.</p> required <p>Returns:</p> Type Description <code>List[Dict[str, str]]</code> <p>list of dict: Rows with typed values and block_fill normalized.</p> Source code in <code>flyfield/io_utils.py</code> <pre><code>def read_csv_rows(filename: str) -&gt; List[Dict[str, str]]:\n    \"\"\"\n    Read CSV rows into a list, converting typed fields and normalizing monetary fills.\n\n    Args:\n        filename (str): Path to CSV file.\n\n    Returns:\n        list of dict: Rows with typed values and block_fill normalized.\n    \"\"\"\n    rows = []\n    currency_field_types = {\"Dollars\", \"DollarCents\", \"Currency\", \"CurrencyDecimal\"}\n\n    try:\n        with open(filename, newline=\"\", encoding=\"utf-8\") as f:\n            reader = csv.DictReader(f)\n            headers = reader.fieldnames or []\n            is_extraction_csv = \"page_num\" in headers\n\n            for row in reader:\n                if is_extraction_csv:\n                    try:\n                        # Convert page_num, line, gap, block_length, height, width fields to correct types\n\n                        row[\"page_num\"] = (\n                            int(row[\"page_num\"]) if row[\"page_num\"].strip() else None\n                        )\n                        row[\"line\"] = int(row[\"line\"]) if row[\"line\"].strip() else None\n                        row[\"gap\"] = float(row[\"gap\"]) if row[\"gap\"].strip() else 0.0\n                        row[\"block_length\"] = (\n                            int(row[\"block_length\"])\n                            if row[\"block_length\"].strip()\n                            else 0\n                        )\n                        row[\"height\"] = float(row.get(\"height\", 0))\n                        row[\"width\"] = float(row.get(\"width\", 0))\n                    except (ValueError, KeyError) as e:\n                        logger.warning(f\"Skipping row due to value error: {e}\")\n                        continue\n                # Rearrange 'fill' to 'block_fill' with formatted monetary fields\n\n                if \"fill\" in row:\n                    fill_value = row[\"fill\"]\n                    field_type = row.get(\"field_type\", \"\")\n\n                    if field_type in currency_field_types and fill_value.strip():\n                        if (\n                            field_type in (\"DollarCents\", \"CurrencyDecimal\")\n                            and \" \" not in fill_value\n                        ):\n                            # Use implied decimal parser for no explicit decimal separator\n\n                            try:\n                                amount = parse_implied_decimal(fill_value)\n                                fill_value = format_money_space(amount, decimal=True)\n                            except Exception as e:\n                                logger.warning(\n                                    f\"Failed to parse implied decimal fill '{fill_value}' for field_type '{field_type}': {e}\"\n                                )\n                        else:\n                            # Use existing parser for explicit decimal formatting\n\n                            decimal = field_type in (\"DollarCents\", \"CurrencyDecimal\")\n                            try:\n                                amount = parse_money_space(fill_value, decimal=decimal)\n                                fill_value = format_money_space(amount, decimal=decimal)\n                            except Exception as e:\n                                logger.warning(\n                                    f\"Failed to parse/format fill '{fill_value}' for field_type '{field_type}': {e}\"\n                                )\n                        row[\"block_fill\"] = fill_value\n                        del row[\"fill\"]\n                rows.append(row)\n    except Exception as e:\n        logger.error(f\"Failed to read CSV rows from {filename}: {e}\")\n    return rows\n</code></pre>"},{"location":"api.html#flyfield.io_utils.save_pdf_form_data_to_csv","title":"<code>save_pdf_form_data_to_csv(pdf_path, csv_path, boxes=None)</code>","text":"<p>Extract PDF form data, convert string values to uppercase and numeric fields to raw numbers, then save as CSV.</p> <p>Parameters:</p> Name Type Description Default <code>pdf_path</code> <code>str</code> <p>Input PDF form file path.</p> required <code>csv_path</code> <code>str</code> <p>Output CSV path.</p> required <code>boxes</code> <code>dict</code> <p>Boxes metadata to enrich form data.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>flyfield/io_utils.py</code> <pre><code>def save_pdf_form_data_to_csv(\n    pdf_path: str, csv_path: str, boxes: Optional[Dict[int, List[dict]]] = None\n) -&gt; None:\n    \"\"\"\n    Extract PDF form data, convert string values to uppercase and numeric fields to raw numbers, then save as CSV.\n\n    Args:\n        pdf_path (str): Input PDF form file path.\n        csv_path (str): Output CSV path.\n        boxes (dict, optional): Boxes metadata to enrich form data.\n\n    Returns:\n        None\n    \"\"\"\n    data = []\n    try:\n        # Extract form data; convert string values to uppercase where applicable\n\n        form_data = {\n            k: v.upper() if isinstance(v, str) else str(v)\n            for k, v in PdfWrapper(pdf_path).data.items()\n            if v is not None and str(v).strip() != \"\" and str(v).strip(\"0\") != \"\"\n        }\n        # Convert raw data dict to list of dicts with explicit 'code' and 'value' keys\n\n        data = [{\"code\": k, \"value\": v} for k, v in form_data.items()]\n    except Exception as e:\n        logger.error(f\"Failed to extract data from {pdf_path}: {e}\")\n    logger.debug(f\"Extracted PDF form data (type={type(data)}), count={len(data)}\")\n\n    if boxes:\n        flat_boxes = [entry for sublist in boxes.values() for entry in sublist]\n        conditional_merge_list(data, flat_boxes, \"code\", [\"field_type\"])\n    try:\n        with open(csv_path, mode=\"w\", newline=\"\", encoding=\"utf-8\") as file:\n            writer = csv.writer(file)\n            # Write CSV header\n\n            writer.writerow([\"code\", \"fill\"])\n\n            # Write each field record as a CSV row\n\n            for field in data:\n                code = field.get(\"code\")\n                fill_value = field.get(\"value\")\n                field_type = field.get(\"field_type\")\n\n                logger.debug(\n                    f\"Code: {code}, Raw Value: {fill_value}, Field Type: {field_type}\"\n                )\n                if field_type in NUMERIC_FIELD_TYPES and isinstance(fill_value, str):\n                    try:\n                        if field_type == \"CurrencyDecimal\":\n                            amount = parse_implied_decimal(fill_value)\n                            fill_value = str(amount)  # Save raw number, not formatted!\n                            logger.debug(f\"Parsed CurrencyDecimal: {fill_value}\")\n                        elif field_type in (\"DollarCents\", \"Dollars\"):\n                            decimal = field_type == \"DollarCents\"\n                            amount = parse_money_space(fill_value, decimal=decimal)\n                            fill_value = str(amount)  # Save raw number, not formatted!\n                            logger.debug(f\"Parsed {field_type}: {fill_value}\")\n                    except Exception as e:\n                        logger.warning(\n                            f\"Failed parsing money value '{fill_value}' for field '{code}': {e}\"\n                        )\n                writer.writerow([code, fill_value])\n    except Exception as e:\n        logger.error(f\"Failed to write CSV file {csv_path}: {e}\")\n</code></pre>"},{"location":"api.html#flyfield.layout","title":"<code>flyfield.layout</code>","text":"<p>Layout processing for PDFs.</p> <p>Calculates layout box positions and formatting.</p>"},{"location":"api.html#flyfield.layout.calculate_layout_fields","title":"<code>calculate_layout_fields(boxes)</code>","text":"<p>Annotate boxes with layout metadata including IDs, lines, blocks,</p> <p>block dimensions, monetary formatting, calculate block dimensions and concatenated fill text per block.</p> <p>Parameters:</p> Name Type Description Default <code>boxes</code> <code>list</code> <p>List of boxes sorted by page and vertical order.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>DefaultDict[int, List[Dict]]</code> <p>Mapping page numbers to lists of annotated boxes.</p> Notes <ul> <li>Vertical tolerance epsilon controls grouping boxes into the same line.</li> <li>Blocks are formed by grouping boxes separated by large gaps (GAP_THRESHOLD).</li> <li>Monetary fills are formatted with spaces and decimals where appropriate.</li> </ul> Source code in <code>flyfield/layout.py</code> <pre><code>def calculate_layout_fields(boxes: List[Dict]) -&gt; DefaultDict[int, List[Dict]]:\n    \"\"\"\n    Annotate boxes with layout metadata including IDs, lines, blocks,\n\n    block dimensions, monetary formatting, calculate block dimensions and\n    concatenated fill text per block.\n\n    Args:\n        boxes (list): List of boxes sorted by page and vertical order.\n\n    Returns:\n        dict: Mapping page numbers to lists of annotated boxes.\n\n    Notes:\n        - Vertical tolerance epsilon controls grouping boxes into the same line.\n        - Blocks are formed by grouping boxes separated by large gaps (GAP_THRESHOLD).\n        - Monetary fills are formatted with spaces and decimals where appropriate.\n    \"\"\"\n    epsilon = 1  # Vertical tolerance for grouping boxes into the same line\n    idx = 0\n    current_page = None\n    line_counter = 1\n    while idx &lt; len(boxes):\n        page_num = boxes[idx][\"page_num\"]\n        if page_num != current_page:\n            current_page = page_num\n            line_counter = 1\n        block_id_counter = 1\n        # Initialize first box in a new line and block\n\n        boxes[idx].update(\n            {\n                \"id\": idx + 1,\n                \"line\": line_counter,\n                \"block_start\": block_id_counter,\n                \"block\": block_id_counter,\n                \"code\": f\"{page_num}-{line_counter}-{block_id_counter}\",\n                \"pgap\": None,  # Gap before this box (none for first)\n            }\n        )\n        block_start = idx\n        j = idx + 1\n        # Group boxes horizontally on the same line by bottom alignment and gap thresholds\n\n        while (\n            j &lt; len(boxes)\n            and boxes[j][\"page_num\"] == page_num\n            and abs(boxes[j][\"bottom\"] - boxes[idx][\"bottom\"]) &lt; epsilon\n        ):\n            boxes[j][\"id\"] = j + 1\n            boxes[j][\"line\"] = line_counter\n            prev_gap = round(boxes[j][\"x0\"] - boxes[j - 1][\"x1\"], 1)\n            boxes[j][\"pgap\"] = prev_gap\n            boxes[j - 1][\"gap\"] = prev_gap\n            if prev_gap &gt;= GAP_THRESHOLD:\n                # Close current block and start a new block\n\n                end_idx = j - 1\n                block_length = (end_idx - block_start) + 1\n                block_width = round(boxes[end_idx][\"x1\"] - boxes[block_start][\"x0\"], 1)\n                boxes[block_start][\"block_length\"] = block_length\n                boxes[block_start][\"block_width\"] = block_width\n                current_box = boxes[block_start]\n                if current_box.get(\"field_type\") not in (\"DollarCents\", \"Dollars\"):\n                    raw_fill = \" \".join(\n                        box.get(\"fill\", \"\") for box in boxes[block_start : end_idx + 1]\n                    )\n                    boxes[block_start][\"block_fill\"] = clean_fill_string(raw_fill)\n                else:\n                    decimal = current_box.get(\"field_type\") == \"DollarCents\"\n                    fill_val = current_box.get(\"fill\", \"\")\n                    try:\n                        if fill_val == \"\" or fill_val is None:\n                            fill_val = 0\n                        current_box[\"fill\"] = format_money_space(fill_val, decimal)\n                    except Exception as e:\n                        logger.warning(f\"Failed to format fill value '{fill_val}': {e}\")\n                        # fall back to original fill value if formatting fails\n\n                        current_box[\"fill\"] = fill_val\n                block_id_counter += 1\n                block_start = j\n                boxes[j].update(\n                    {\n                        \"block_start\": block_id_counter,\n                        \"block\": block_id_counter,\n                        \"code\": f\"{page_num}-{line_counter}-{block_id_counter}\",\n                    }\n                )\n            else:\n                # Continue current block\n\n                boxes[j].update(\n                    {\n                        \"block_start\": block_id_counter,\n                        \"block\": block_id_counter,\n                        \"code\": f\"{page_num}-{line_counter}-{block_id_counter}\",\n                    }\n                )\n            j += 1\n        # Close last block on the line\n\n        end_idx = j - 1\n        block_length = (end_idx - block_start) + 1\n        block_width = round(boxes[end_idx][\"x1\"] - boxes[block_start][\"x0\"], 1)\n        boxes[block_start][\"block_length\"] = block_length\n        boxes[block_start][\"block_width\"] = block_width\n        current_box = boxes[block_start]\n        if current_box.get(\"field_type\") not in (\"DollarCents\", \"Dollars\"):\n            raw_fill = \" \".join(\n                box.get(\"fill\", \"\") for box in boxes[block_start : end_idx + 1]\n            )\n            boxes[block_start][\"block_fill\"] = clean_fill_string(raw_fill)\n        else:\n            decimal = current_box.get(\"field_type\") == \"DollarCents\"\n            fill_val = current_box.get(\"fill\", \"\")\n            try:\n                if fill_val == \"\" or fill_val is None:\n                    fill_val = 0\n                current_box[\"fill\"] = format_money_space(fill_val, decimal)\n            except Exception as e:\n                logger.warning(f\"Failed to format fill value '{fill_val}': {e}\")\n                current_box[\"fill\"] = fill_val\n        boxes[end_idx][\"gap\"] = None  # No gap after the last box in the line\n        line_counter += 1\n        idx = j\n    block_id_counter = 1\n    # Group boxes by page number, only include blocks with length &gt;= 1, then sort by line and left coordinate\n\n    page_dict = defaultdict(list)\n    for box in boxes:\n        if box.get(\"block_length\", 0) &gt;= 1:\n            page_dict[box[\"page_num\"]].append(box)\n    for page_num in page_dict:\n        page_dict[page_num].sort(key=lambda r: (r.get(\"line\", 0), r.get(\"left\", 0)))\n    return page_dict\n</code></pre>"},{"location":"api.html#flyfield.layout.assign_numeric_blocks","title":"<code>assign_numeric_blocks(page_dict)</code>","text":"<p>Merge and assign numeric block types based on heuristics of adjacency and length.</p> <p>Parameters:</p> Name Type Description Default <code>page_dict</code> <code>dict</code> <p>Keyed by page number with boxes list.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>DefaultDict[int, List[Dict]]</code> <p>Updated page_dict with numeric block types assigned.</p> Notes <p>Modifies the page_dict in place:</p> <ul> <li>Merges runs of adjacent blocks of length 3 if gaps between them are small.</li> <li>Optionally prepends certain preceding blocks to runs.</li> <li>Assigns field types \"CurrencyDecimal\" or \"Currency\" based on heuristics.</li> <li>Aggregates block lengths, widths, and concatenates fill strings.</li> </ul> Source code in <code>flyfield/layout.py</code> <pre><code>def assign_numeric_blocks(\n    page_dict: DefaultDict[int, List[Dict]],\n) -&gt; DefaultDict[int, List[Dict]]:\n    \"\"\"\n    Merge and assign numeric block types based on heuristics of adjacency and length.\n\n    Args:\n        page_dict (dict): Keyed by page number with boxes list.\n\n    Returns:\n        dict: Updated page_dict with numeric block types assigned.\n\n    Notes:\n        Modifies the page_dict in place:\n\n        - Merges runs of adjacent blocks of length 3 if gaps between them are small.\n        - Optionally prepends certain preceding blocks to runs.\n        - Assigns field types \"CurrencyDecimal\" or \"Currency\" based on heuristics.\n        - Aggregates block lengths, widths, and concatenates fill strings.\n    \"\"\"\n    for page_num, rows in page_dict.items():\n        rows.sort(key=lambda r: (r.get(\"line\", 0), r.get(\"left\", 0)))\n        page_dict[page_num] = rows\n        i = 0\n        while i &lt; len(rows):\n            block_length = rows[i].get(\"block_length\", 0)\n            if block_length == 3:\n                run = [rows[i]]\n                j = i + 1\n                # Collect consecutive blocks of length 3 separated by small gaps\n\n                while j &lt; len(rows):\n                    next_block_length = rows[j].get(\"block_length\", 0)\n                    next_pgap = rows[j].get(\"pgap\")\n                    if (\n                        next_block_length == 3\n                        and next_pgap is not None\n                        and 0 &lt; next_pgap &lt; 8\n                    ):\n                        run.append(rows[j])\n                        j += 1\n                    else:\n                        break\n                # Optionally prepend preceding block if conditions met\n\n                if len(run) &gt;= 2 and i &gt; 0:\n                    prev = rows[i - 1]\n                    first_pgap = rows[i].get(\"pgap\", 0)\n                    if (\n                        prev.get(\"block_length\") in (1, 2)\n                        and first_pgap is not None\n                        and 1 &lt;= first_pgap &lt; 8\n                    ):\n                        run.insert(0, prev)\n                        i -= 1\n                next_idx = j\n                next_block_length = (\n                    rows[next_idx].get(\"block_length\") if next_idx &lt; len(rows) else None\n                )\n                next_gap = rows[next_idx].get(\"pgap\") if next_idx &lt; len(rows) else None\n                if len(run) &gt;= 2:\n                    if (\n                        next_idx &lt; len(rows)\n                        and next_block_length == 2\n                        and next_gap is not None\n                    ):\n                        run.append(rows[next_idx])\n                        run[0][\"field_type\"] = \"CurrencyDecimal\"\n                        j += 1\n                    else:\n                        run[0][\"field_type\"] = \"Currency\"\n                    # Aggregate block length and width for the merged block\n\n                    block_length_sum = sum(\n                        r.get(\"block_length\", 0) for r in run if r.get(\"block_length\")\n                    )\n                    run[0][\"block_length\"] = block_length_sum\n                    first_left = min(r.get(\"left\", float(\"inf\")) for r in run)\n                    last_left = max(r.get(\"left\", float(\"-inf\")) for r in run)\n                    run[0][\"block_width\"] = (\n                        last_left - first_left + run[-1][\"block_width\"]\n                    )\n                    fills = [\n                        r.get(\"block_fill\", \"\") for r in run if r.get(\"block_fill\")\n                    ]\n                    run[0][\"block_fill\"] = \"\".join(fills).strip()\n                    # Clear subordinate blocks lengths and fills\n\n                    for r in run[1:]:\n                        r[\"block_length\"] = None\n                        r[\"block_width\"] = None\n                        r[\"block_fill\"] = None\n                    i = j\n                else:\n                    i += 1\n            else:\n                i += 1\n    return page_dict\n</code></pre>"},{"location":"api.html#flyfield.markup_and_fields","title":"<code>flyfield.markup_and_fields</code>","text":"<p>Functions for PDF markup and form field annotation.</p>"},{"location":"api.html#flyfield.markup_and_fields.markup_pdf","title":"<code>markup_pdf(pdf_path, page_dict, output_pdf_path, mark_color=(0, 0, 1), mark_radius=1)</code>","text":"<p>Mark PDF with circles and codes at block locations for debugging.</p> <p>Parameters:</p> Name Type Description Default <code>pdf_path</code> <code>str</code> <p>Input PDF file.</p> required <code>page_dict</code> <code>dict</code> <p>Pages and boxes with layout info.</p> required <code>output_pdf_path</code> <code>str</code> <p>Output marked PDF file path.</p> required <code>mark_color</code> <code>tuple</code> <p>RGB float tuple for marker color.</p> <code>(0, 0, 1)</code> <code>mark_radius</code> <code>int or float</code> <p>Radius of circle marks.</p> <code>1</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>flyfield/markup_and_fields.py</code> <pre><code>def markup_pdf(\n    pdf_path: str,\n    page_dict: Dict[int, List[Dict]],\n    output_pdf_path: str,\n    mark_color: Tuple[float, float, float] = (0, 0, 1),\n    mark_radius: float = 1,\n) -&gt; None:\n    \"\"\"\n    Mark PDF with circles and codes at block locations for debugging.\n\n    Args:\n        pdf_path (str): Input PDF file.\n        page_dict (dict): Pages and boxes with layout info.\n        output_pdf_path (str): Output marked PDF file path.\n        mark_color (tuple): RGB float tuple for marker color.\n        mark_radius (int or float): Radius of circle marks.\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        doc = fitz.open(pdf_path)\n    except Exception as e:\n        logger.error(f\"Failed to open PDF for markup: {e}\")\n        return\n    for page_num, boxes in sorted(page_dict.items()):\n        if config.PDF_PAGES and page_num not in config.PDF_PAGES:\n            continue\n        page = doc[page_num - 1]\n        page_height = page.rect.height\n        shape = page.new_shape()\n\n        for box in boxes:\n            # Only mark boxes that have a meaningful block_length\n\n            if box.get(\"block_length\") not in (\"\", 0, None):\n                x, y_raw = box.get(\"x0\"), box.get(\"y0\")\n                y = page_height - y_raw\n                shape.draw_circle((x, y), mark_radius)\n\n                point = fitz.Point(x + 4, y)\n                shape.insert_text(\n                    point,\n                    str(box.get(\"code\", \"?\")),\n                    fontsize=8,\n                    color=mark_color,\n                    morph=(point, fitz.Matrix(1, 0, 0, 1, 0, 0).prerotate(45)),\n                )\n        shape.finish(color=mark_color, fill=None)\n        shape.commit()\n    try:\n        doc.save(output_pdf_path)\n    except Exception as e:\n        logger.error(f\"Failed to save output PDF: {e}\")\n    finally:\n        doc.close()\n</code></pre>"},{"location":"api.html#flyfield.markup_and_fields.adjust_form_boxes","title":"<code>adjust_form_boxes(row, width, block_length)</code>","text":"<p>Adjust the position and width of form boxes depending on field type and block length.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>dict</code> <p>Box attributes.</p> required <code>width</code> <code>float</code> <p>Original block width.</p> required <code>block_length</code> <code>int</code> <p>Block length in contained boxes.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[float, float, List[str]]</code> <p>(adjusted x, adjusted width, list of extra args)</p> Source code in <code>flyfield/markup_and_fields.py</code> <pre><code>def adjust_form_boxes(\n    row: Dict,\n    width: float,\n    block_length: int,\n) -&gt; Tuple[float, float, List[str]]:\n    \"\"\"\n    Adjust the position and width of form boxes depending on field type and block length.\n\n    Args:\n        row (dict): Box attributes.\n        width (float): Original block width.\n        block_length (int): Block length in contained boxes.\n\n    Returns:\n        tuple: (adjusted x, adjusted width, list of extra args)\n    \"\"\"\n    x = float(row[\"left\"])\n    field_type = row.get(\"field_type\")\n    extra_args = [\"alignment=2\"]\n\n    if (\n        block_length == 1\n        and width &gt; 14\n        and field_type not in (\"Currency\", \"CurrencyDecimal\")\n    ):\n        # Reduce width by size of layout characters\n\n        width_adjusted = width\n        if field_type == \"Dollars\":\n            width_adjusted -= 21\n        elif field_type == \"DollarCents\":\n            width_adjusted -= 4\n        return x, max(0, width_adjusted), extra_args\n    if field_type in (\"Currency\", \"CurrencyDecimal\"):\n        gap_adj = (2 * GAP + GAP_GROUP) / 3 / 2\n        gap_start = (gap_adj * (((block_length - 1) % 3) + 1)) / 2 + F\n        if field_type == \"CurrencyDecimal\":\n            gap_start += F * 2\n        gap_end = gap_adj + F * 2 if field_type == \"Currency\" else (gap_adj * 3) / 2\n    else:\n        gap_adj = GAP\n        gap_start = gap_end = gap_adj / 2 + F\n        extra_args[0] = \"alignment=0\"\n    x -= gap_start\n    width_adjusted = width + gap_start + gap_end\n    extra_args += [\n        f\"max_length={block_length}\" if block_length else \"max_length=None\",\n        \"comb=True\",\n    ]\n    return x, max(0, width_adjusted), extra_args\n</code></pre>"},{"location":"api.html#flyfield.markup_and_fields.generate_form_fields_script","title":"<code>generate_form_fields_script(csv_path, input_pdf, output_pdf_with_fields, script_path)</code>","text":"<p>Generate a standalone Python script to create PDF form fields from CSV block data.</p> <p>Parameters:</p> Name Type Description Default <code>csv_path</code> <code>str</code> <p>CSV data path.</p> required <code>input_pdf</code> <code>str</code> <p>Input PDF to annotate.</p> required <code>output_pdf_with_fields</code> <code>str</code> <p>Output annotated PDF.</p> required <code>script_path</code> <code>str</code> <p>Output script file path.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Path to the generated script file.</p> Source code in <code>flyfield/markup_and_fields.py</code> <pre><code>def generate_form_fields_script(\n    csv_path: str,\n    input_pdf: str,\n    output_pdf_with_fields: str,\n    script_path: str,\n) -&gt; str:\n    \"\"\"\n    Generate a standalone Python script to create PDF form fields from CSV block data.\n\n    Args:\n        csv_path (str): CSV data path.\n        input_pdf (str): Input PDF to annotate.\n        output_pdf_with_fields (str): Output annotated PDF.\n        script_path (str): Output script file path.\n\n    Returns:\n        str: Path to the generated script file.\n    \"\"\"\n    lines = [\n        \"from PyPDFForm import Fields, PdfWrapper\",\n        f'pdf = PdfWrapper(\"{input_pdf}\")',\n    ]\n    try:\n        with open(csv_path, newline=\"\", encoding=\"utf-8\") as f:\n            reader = csv.DictReader(f)\n            current_page = None\n            for row in reader:\n                page_number = int(row[\"page_num\"])\n\n                # Skip rows whose page number is not in PDF_PAGES if PDF_PAGES filter is set\n\n                if config.PDF_PAGES and page_number not in config.PDF_PAGES:\n                    continue\n                code = row[\"code\"]\n                if (\n                    not code\n                    or row[\"block_length\"] in (\"\", \"0\")\n                    or row.get(\"field_type\") == \"Skip\"\n                ):\n                    continue\n                if page_number != current_page:\n                    lines.append(f'print(\"Starting page {page_number}...\", flush=True)')\n                    current_page = page_number\n                block_length = (\n                    int(float(row[\"block_length\"]))\n                    if row[\"block_length\"] not in (\"\", \"0\")\n                    else 0\n                )\n                width = (\n                    float(row[\"block_width\"])\n                    if row[\"block_width\"] not in (\"\", \"0\")\n                    else 0\n                )\n                y, height = float(row[\"bottom\"]), float(row.get(\"height\", 0))\n                x, width_adjusted, extra_args = adjust_form_boxes(\n                    row, width, block_length\n                )\n                sanitized_code = re.sub(r\"[^\\w\\-_]\", \"_\", code)\n                base_args = [\n                    #                    'widget_type=\"text\"',\n                    f'name=\"{sanitized_code}\"',\n                    f\"page_number={page_number}\",\n                    f\"x={x:.2f}\",\n                    f\"y={y:.2f}\",\n                    f\"height={height:.2f}\",\n                    f\"width={width_adjusted:.2f}\",\n                    \"bg_color=(0,0,0,0)\",\n                    \"border_color=(0,0,0,0)\",\n                    \"border_width=0\",\n                ]\n                args = [*base_args, *extra_args]\n                lines.append(f\"pdf.create_field(Fields.TextField({', '.join(args)}))\")\n            lines.extend(\n                [\n                    f'pdf.write(\"{output_pdf_with_fields}\")',\n                    'print(\"Created form fields PDF.\", flush=True)',\n                ]\n            )\n        with open(script_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(\"\\n\".join(lines))\n    except Exception as e:\n        logger.error(f\"Failed to generate form fields script: {e}\")\n    return script_path\n</code></pre>"},{"location":"api.html#flyfield.markup_and_fields.run_standalone_script","title":"<code>run_standalone_script(script_path)</code>","text":"<p>Execute a standalone script for PDF form field creation.</p> <p>Parameters:</p> Name Type Description Default <code>script_path</code> <code>str</code> <p>Path to the script to run.</p> required Source code in <code>flyfield/markup_and_fields.py</code> <pre><code>def run_standalone_script(script_path: str) -&gt; None:\n    \"\"\"\n    Execute a standalone script for PDF form field creation.\n\n    Args:\n        script_path (str): Path to the script to run.\n    \"\"\"\n    print(f\"Running generated form field creation script: {script_path}\")\n    try:\n        result = subprocess.run([sys.executable, \"-u\", script_path], text=True)\n        if result.returncode != 0:\n            raise RuntimeError(\n                f\"Generated script failed with exit code {result.returncode}\"\n            )\n    except Exception as e:\n        logger.error(f\"Error running generated script: {e}\")\n</code></pre>"},{"location":"api.html#flyfield.markup_and_fields.run_fill_pdf_fields","title":"<code>run_fill_pdf_fields(csv_path, output_pdf_path, template_pdf_path, generator_script_path, boxes=None)</code>","text":"<p>Generates and runs a standalone Python script to fill PDF form fields using PyPDFForm,</p> <p>based on data from a CSV file with 'code' and 'fill' columns.</p> <p>Parameters:</p> Name Type Description Default <code>csv_path</code> <code>str</code> <p>Path to the CSV input file.</p> required <code>output_pdf_path</code> <code>str</code> <p>Path where the filled PDF should be saved.</p> required <code>template_pdf_path</code> <code>str</code> <p>Path to the input (template) PDF file.</p> required <code>generator_script_path</code> <code>str</code> <p>Path where the generated fill script will be saved.</p> required Source code in <code>flyfield/markup_and_fields.py</code> <pre><code>def run_fill_pdf_fields(\n    csv_path: str,\n    output_pdf_path: str,\n    template_pdf_path: str,\n    generator_script_path: str,\n    boxes: Optional[Dict[int, List[Dict]]] = None,\n) -&gt; None:\n    \"\"\"\n    Generates and runs a standalone Python script to fill PDF form fields using PyPDFForm,\n\n    based on data from a CSV file with 'code' and 'fill' columns.\n\n    Args:\n        csv_path (str): Path to the CSV input file.\n        output_pdf_path (str): Path where the filled PDF should be saved.\n        template_pdf_path (str): Path to the input (template) PDF file.\n        generator_script_path (str): Path where the generated fill script will be saved.\n    \"\"\"\n    from .utils import format_money_space, parse_money_space\n\n    fill_data = {}\n    try:\n        with open(csv_path, newline=\"\", encoding=\"utf-8\") as f:\n            reader = csv.DictReader(f)\n            rows = []\n            for row in reader:\n                # Clean row values\n\n                stripped_row = {\n                    k: v.strip() if isinstance(v, str) else v for k, v in row.items()\n                }\n                if all(v == \"\" or v == \"0\" for v in stripped_row.values()):\n                    continue\n                rows.append(stripped_row)\n        # Flatten boxes if any and merge to rows\n\n        if boxes:\n            flat_boxes = [entry for sublist in boxes.values() for entry in sublist]\n            conditional_merge_list(rows, flat_boxes, \"code\", [\"field_type\"])\n        for row in rows:\n            field = row.get(\"code\")\n            value = row.get(\"fill\")\n            field_type = row.get(\"field_type\", \"\")\n            if not field or value in (\"\", \"0\"):\n                continue\n            if field_type in (\"Dollars\", \"DollarCents\"):\n                decimal = field_type == \"DollarCents\"\n                try:\n                    amount = parse_money_space(value, decimal=decimal)\n                    value = format_money_space(amount, decimal=decimal)\n                except Exception as e:\n                    print(\n                        f\"Warning: Could not format value '{value}' for field_type '{field_type}': {e}\"\n                    )\n            elif field_type in (\"Currency\", \"CurrencyDecimal\"):\n                import re\n\n                value = re.sub(r\"\\D\", \"\", value)\n            fill_data[field] = value\n    except Exception as e:\n        print(f\"Error reading CSV {csv_path}: {e}\")\n        return\n    fill_dict_items = \",\\n \".join(f'\"{k}\": {repr(v)}' for k, v in fill_data.items())\n    script_content = f\"\"\"\\\nfrom PyPDFForm import PdfWrapper\nprint(\"Starting to fill PDF fields...\", flush=True)\ntry:\n    filled = PdfWrapper(\n        \"{template_pdf_path}\",\n        adobe_mode=False\n    ).fill(\n        {{\n            {fill_dict_items}\n        }},\n        flatten=False\n    )\n    filled.write(\"{output_pdf_path}\")\n    print(\"Filled PDF saved to {output_pdf_path}\", flush=True)\nexcept Exception as e:\n    print(f\"Exception during filling: {{e}}\", file=sys.stderr, flush=True)\n    sys.exit(1)\n\"\"\"\n\n    try:\n        with open(generator_script_path, \"w\", encoding=\"utf-8\") as script_file:\n            script_file.write(script_content)\n        print(f\"Generated fill script saved to {generator_script_path}\")\n    except Exception as e:\n        print(f\"Error writing fill script to {generator_script_path}: {e}\")\n        return\n    try:\n        result = subprocess.run(\n            [sys.executable, generator_script_path], capture_output=True, text=True\n        )\n        print(\"Fill script stdout:\")\n        print(result.stdout)\n        print(\"Fill script stderr:\")\n        print(result.stderr)\n        if result.returncode != 0:\n            print(f\"Fill script failed with exit code {result.returncode}\")\n        else:\n            print(\"Fill script completed successfully.\")\n    except Exception as e:\n        print(f\"Error running fill script: {e}\")\n</code></pre>"},{"location":"api.html#flyfield.utils","title":"<code>flyfield.utils</code>","text":"<p>General utility functions.</p> <p>Helper functions for parsing, formatting, and validation.</p>"},{"location":"api.html#flyfield.utils.add_suffix_to_filename","title":"<code>add_suffix_to_filename(filename, suffix)</code>","text":"<p>Add a suffix before the file extension in a filename.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Original filename.</p> required <code>suffix</code> <code>str</code> <p>Suffix to add.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Filename with suffix added.</p> Source code in <code>flyfield/utils.py</code> <pre><code>def add_suffix_to_filename(filename: str, suffix: str) -&gt; str:\n    \"\"\"\n    Add a suffix before the file extension in a filename.\n\n    Args:\n        filename (str): Original filename.\n        suffix (str): Suffix to add.\n\n    Returns:\n        str: Filename with suffix added.\n    \"\"\"\n    base, ext = os.path.splitext(filename)\n    return f\"{base}{suffix}{ext}\"\n</code></pre>"},{"location":"api.html#flyfield.utils.colour_match","title":"<code>colour_match(color, target_color=TARGET_COLOUR, tol=0.001)</code>","text":"<p>Check if a color matches a target within a tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>tuple</code> <p>RGB color tuple.</p> required <code>target_color</code> <code>tuple</code> <p>RGB target color.</p> <code>COLOR_WHITE</code> <code>tol</code> <code>float</code> <p>Allowed tolerance.</p> <code>0.001</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if colors match within tolerance.</p> Note <p>If the input color has an alpha channel (RGBA), the alpha component is ignored.</p> Source code in <code>flyfield/utils.py</code> <pre><code>def colour_match(\n    color: Tuple[float, ...],\n    target_color: Tuple[float, float, float] = TARGET_COLOUR,\n    tol: float = 1e-3,\n) -&gt; bool:\n    \"\"\"\n    Check if a color matches a target within a tolerance.\n\n    Args:\n        color (tuple): RGB color tuple.\n        target_color (tuple): RGB target color.\n        tol (float): Allowed tolerance.\n\n    Returns:\n        bool: True if colors match within tolerance.\n\n    Note:\n        If the input color has an alpha channel (RGBA), the alpha component is ignored.\n    \"\"\"\n    if not color or len(color) &lt; 3:\n        return False\n    # Compare only RGB channels; ignore alpha if present\n\n    return all(abs(a - b) &lt; tol for a, b in zip(color[:3], target_color))\n</code></pre>"},{"location":"api.html#flyfield.utils.int_to_rgb","title":"<code>int_to_rgb(color_int)</code>","text":"<p>Convert a 24-bit integer color in 0xRRGGBB format to normalized RGB tuple of floats.</p> <p>Parameters:</p> Name Type Description Default <code>color_int</code> <code>int</code> <p>Integer encoding color as 0xRRGGBB.</p> required <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[float, float, float]</code> <p>Normalized (r, g, b) floats in range [0.0, 1.0].</p> Source code in <code>flyfield/utils.py</code> <pre><code>def int_to_rgb(color_int: int) -&gt; Tuple[float, float, float]:\n    \"\"\"\n    Convert a 24-bit integer color in 0xRRGGBB format to normalized RGB tuple of floats.\n\n    Args:\n        color_int (int): Integer encoding color as 0xRRGGBB.\n\n    Returns:\n        tuple: Normalized (r, g, b) floats in range [0.0, 1.0].\n    \"\"\"\n    r = ((color_int &gt;&gt; 16) &amp; 0xFF) / 255\n    g = ((color_int &gt;&gt; 8) &amp; 0xFF) / 255\n    b = (color_int &amp; 0xFF) / 255\n    return (r, g, b)\n</code></pre>"},{"location":"api.html#flyfield.utils.clean_fill_string","title":"<code>clean_fill_string(line_text)</code>","text":"<p>Clean a concatenated fill text string by removing single spaces while preserving double spaces as single spaces.</p> <p>Parameters:</p> Name Type Description Default <code>line_text</code> <code>str</code> <p>Raw line text.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Cleaned fill string.</p> Source code in <code>flyfield/utils.py</code> <pre><code>def clean_fill_string(line_text: str) -&gt; str:\n    \"\"\"\n    Clean a concatenated fill text string by removing single spaces while preserving double spaces as single spaces.\n\n    Args:\n        line_text (str): Raw line text.\n\n    Returns:\n        str: Cleaned fill string.\n    \"\"\"\n    line_text = re.sub(r\" {2,}\", \"&lt;&lt;&lt;SPACE&gt;&gt;&gt;\", line_text)\n    line_text = line_text.replace(\" \", \"\")\n    line_text = line_text.replace(\"&lt;&lt;&lt;SPACE&gt;&gt;&gt;\", \" \")\n    return line_text\n</code></pre>"},{"location":"api.html#flyfield.utils.allowed_text","title":"<code>allowed_text(text, field_type=None)</code>","text":"<p>Determine if text is allowed based on predefined rules and field type.</p> <p>Helps to filter out pre-filled or invalid box contents.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text extracted from a box.</p> required <code>field_type</code> <code>str or None</code> <p>Optional current field type guess to refine allowed patterns.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>tuple</code> <code>Tuple[bool, Optional[str]]</code> <p>(bool indicating if allowed, detected field type or None)</p> Source code in <code>flyfield/utils.py</code> <pre><code>def allowed_text(\n    text: str, field_type: Optional[str] = None\n) -&gt; Tuple[bool, Optional[str]]:\n    \"\"\"\n    Determine if text is allowed based on predefined rules and field type.\n\n    Helps to filter out pre-filled or invalid box contents.\n\n    Args:\n        text (str): Text extracted from a box.\n        field_type (str or None): Optional current field type guess to refine allowed patterns.\n\n    Returns:\n        tuple: (bool indicating if allowed, detected field type or None)\n    \"\"\"\n    allowed_text_by_type = {\n        \"DollarCents\": {\".\", \".00.\"},\n        \"Dollars\": {\".00\", \".00.00\"},\n    }\n    generic_allowed_text = {\"S\", \"M\", \"I\", \"T\", \"H\"}\n    if field_type in allowed_text_by_type:\n        allowed_set = allowed_text_by_type[field_type] | generic_allowed_text\n        if text in allowed_set:\n            return True, field_type\n        else:\n            return False, None\n    else:\n        for ftype, texts in allowed_text_by_type.items():\n            if text in texts:\n                return True, ftype\n        if text in generic_allowed_text:\n            return True, None\n        return False, None\n</code></pre>"},{"location":"api.html#flyfield.utils.format_money_space","title":"<code>format_money_space(amount, decimal=True)</code>","text":"<p>Format a numeric amount to a string with space-separated thousands and optional decimal.</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>float or int</code> <p>Numeric amount to format.</p> required <code>decimal</code> <code>bool</code> <p>Whether to include two decimal places.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Formatted monetary string.</p> Source code in <code>flyfield/utils.py</code> <pre><code>def format_money_space(amount: float, decimal: bool = True) -&gt; str:\n    \"\"\"\n    Format a numeric amount to a string with space-separated thousands and optional decimal.\n\n    Args:\n        amount (float or int): Numeric amount to format.\n        decimal (bool): Whether to include two decimal places.\n\n    Returns:\n        str: Formatted monetary string.\n    \"\"\"\n    if decimal:\n        s = f\"{amount:,.2f}\"\n        int_part, dec_part = s.split(\".\")\n        int_part = int_part.replace(\",\", \" \")\n        return f\"{int_part} {dec_part}\"\n    else:\n        s = f\"{int(amount):,}\"\n        int_part = s.replace(\",\", \" \")\n        return int_part\n</code></pre>"},{"location":"api.html#flyfield.utils.parse_money_space","title":"<code>parse_money_space(money_str, decimal=True)</code>","text":"<p>Parse a monetary string with optional implied decimal space formatting.</p> <p>Parameters:</p> Name Type Description Default <code>money_str</code> <code>str</code> <p>Monetary string to parse (e.g., \"12 345\" means 123.45 if decimal is True).</p> required <code>decimal</code> <code>bool</code> <p>Whether the last two digits represent cents (default True).</p> <code>True</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Parsed monetary value as a float.</p> Source code in <code>flyfield/utils.py</code> <pre><code>def parse_money_space(money_str: str, decimal: bool = True) -&gt; float:\n    \"\"\"\n    Parse a monetary string with optional implied decimal space formatting.\n\n    Args:\n        money_str (str): Monetary string to parse (e.g., \"12 345\" means 123.45 if decimal is True).\n        decimal (bool): Whether the last two digits represent cents (default True).\n\n    Returns:\n        float: Parsed monetary value as a float.\n    \"\"\"\n    if decimal:\n        if \" \" in money_str:\n            parts = money_str.rsplit(\" \", 1)\n            int_part = parts[0].replace(\" \", \"\")\n            dec_part = parts[1]\n            combined = f\"{int_part}.{dec_part}\"\n            return float(combined)\n        else:\n            # No decimal part found, treat as int\n\n            return float(money_str.replace(\" \", \"\"))\n    else:\n        return int(money_str.replace(\" \", \"\"))\n</code></pre>"},{"location":"api.html#flyfield.utils.parse_implied_decimal","title":"<code>parse_implied_decimal(s)</code>","text":"<p>Parse a numeric string with implied decimal (last two digits as decimals).</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>Numeric string (e.g., \"12345\" -&gt; 123.45).</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Parsed float value.</p> Source code in <code>flyfield/utils.py</code> <pre><code>def parse_implied_decimal(s: str) -&gt; float:\n    \"\"\"\n    Parse a numeric string with implied decimal (last two digits as decimals).\n\n    Args:\n        s (str): Numeric string (e.g., \"12345\" -&gt; 123.45).\n\n    Returns:\n        float: Parsed float value.\n    \"\"\"\n    s = s.strip()\n    digits_only = re.sub(r\"\\D\", \"\", s)\n\n    if not digits_only:\n        return 0.0\n    if len(digits_only) &lt;= 2:\n        # If only 1 or 2 digits, treat as fractional part\n\n        combined = f\"0.{digits_only.zfill(2)}\"\n    else:\n        combined = f\"{digits_only[:-2]}.{digits_only[-2:]}\"\n    return float(combined)\n</code></pre>"},{"location":"api.html#flyfield.utils.version","title":"<code>version()</code>","text":"<p>Return the current version string of the library/module.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Version string.</p> Source code in <code>flyfield/utils.py</code> <pre><code>def version() -&gt; str:\n    \"\"\"\n    Return the current version string of the library/module.\n\n    Returns:\n        str: Version string.\n    \"\"\"\n    try:\n        # Python 3.8+\n\n        from importlib.metadata import PackageNotFoundError\n        from importlib.metadata import version as pkg_version\n    except ImportError:\n        # For Python &lt;3.8\n\n        from importlib_metadata import PackageNotFoundError\n        from importlib_metadata import version as pkg_version\n    try:\n        return pkg_version(\"flyfield\")\n    except PackageNotFoundError:\n        return \"unknown\"\n</code></pre>"},{"location":"api.html#flyfield.utils.parse_pages","title":"<code>parse_pages(pages_str)</code>","text":"<p>Parse a string specifying pages or page ranges into a list of page integers.</p> <p>Parameters:</p> Name Type Description Default <code>pages_str</code> <code>str</code> <p>Pages specified as a comma-separated list or ranges (e.g., \"1,3-5\").</p> required <p>Returns:</p> Type Description <code>List[int]</code> <p>list[int]: List of individual page numbers.</p> Source code in <code>flyfield/utils.py</code> <pre><code>def parse_pages(pages_str: str) -&gt; List[int]:\n    \"\"\"\n    Parse a string specifying pages or page ranges into a list of page integers.\n\n    Args:\n        pages_str (str): Pages specified as a comma-separated list or ranges (e.g., \"1,3-5\").\n\n    Returns:\n        list[int]: List of individual page numbers.\n    \"\"\"\n    pages = set()\n    for part in pages_str.split(\",\"):\n        part = part.strip()\n        if \"-\" in part:\n            start_str, end_str = part.split(\"-\")\n            start, end = int(start_str), int(end_str)\n            pages.update(range(start, end + 1))\n        else:\n            pages.add(int(part))\n    return sorted(pages)\n</code></pre>"},{"location":"api.html#flyfield.utils.conditional_merge_list","title":"<code>conditional_merge_list(main_list, ref_list, match_key, keys_to_merge)</code>","text":"<p>Conditionally merge dictionaries in a main list with those in a reference list.</p> <p>Parameters:</p> Name Type Description Default <code>main_list</code> <code>list[dict]</code> <p>Primary list of dictionaries.</p> required <code>ref_list</code> <code>list[dict]</code> <p>Reference list of dictionaries.</p> required <code>match_key</code> <code>str</code> <p>Key to match dictionaries.</p> required <code>keys_to_merge</code> <code>list[str]</code> <p>Keys to merge from ref_list into main_list.</p> required <p>Returns:</p> Name Type Description <code>None</code> <code>None</code> <p>Modifies main_list in place.</p> Source code in <code>flyfield/utils.py</code> <pre><code>def conditional_merge_list(\n    main_list: List[Dict],\n    ref_list: List[Dict],\n    match_key: str,\n    keys_to_merge: List[str],\n) -&gt; None:\n    \"\"\"\n    Conditionally merge dictionaries in a main list with those in a reference list.\n\n    Args:\n        main_list (list[dict]): Primary list of dictionaries.\n        ref_list (list[dict]): Reference list of dictionaries.\n        match_key (str): Key to match dictionaries.\n        keys_to_merge (list[str]): Keys to merge from ref_list into main_list.\n\n    Returns:\n        None: Modifies main_list in place.\n    \"\"\"\n    # Build lookup dictionary for efficient matching\n\n    ref_lookup = {item[match_key]: item for item in ref_list if match_key in item}\n    for record in main_list:\n        ref_record = ref_lookup.get(record.get(match_key))\n        if ref_record:\n            for key in keys_to_merge:\n                if key in ref_record:\n                    record[key] = ref_record[key]\n</code></pre>"},{"location":"config.html","title":"Configuration and Constants for flyfield","text":"<p>This document describes configuration settings, constants, and customizable parameters available in flyfield to tailor processing and output.</p>"},{"location":"config.html#configuration-overview","title":"Configuration Overview","text":"<p>flyfield uses a combination of CLI flags, internal constants, and Python APIs to control behavior during extraction, field generation, filling, and capturing. At its core, flyfield relies on detecting white vector boxes in PDFs, applying heuristics, and mapping them into interactive form fields.</p>"},{"location":"config.html#cli-configuration-options","title":"CLI Configuration Options","text":"Option Description <code>--input-pdf FILE</code> Specifies the input PDF file. <code>--pdf-pages</code> Comma-separated list or ranges of pages to process, e.g., <code>\"1,3-5,7\"</code>. <code>--input-csv FILE</code> Specify a CSV file for input blocks or captured data. Skips detection step. <code>--markup</code> Generate a markup PDF showing detected placeholders and field codes. <code>--fields</code> Generate interactive PDF fields from detected or CSV-loaded data. <code>--fill FILE</code> Provide a CSV file to fill PDF form fields with data. <code>--capture</code> Capture filled field data from PDF back into CSV. <code>--debug</code> Enable verbose debug output including intermediate CSV files."},{"location":"config.html#internal-configuration-constants","title":"Internal Configuration Constants","text":"<p>These constants (defined in <code>flyfield/config.py</code>) control thresholds, suffixes, and color detection used internally.</p> Parameter Description Default Value <code>DEFAULT_INPUT_PDF</code> Default input PDF filename <code>\"input.pdf\"</code> <code>DEFAULT_CAPTURE_SUFFIX</code> Filename suffix for captured filled fields CSV <code>\"-capture.csv\"</code> <code>DEFAULT_FIELD_GENERATOR_SUFFIX</code> Filename suffix for generated field creation script <code>\"-field-generator.py\"</code> <code>DEFAULT_FILLER_SUFFIX</code> Filename suffix for generated field filling script <code>\"-filler.py\"</code> <code>DEFAULT_MARKUP_SUFFIX</code> Filename suffix for markup PDF <code>\"-markup\"</code> <code>DEFAULT_FIELDS_SUFFIX</code> Filename suffix for generated fields PDF <code>\"-fields\"</code> <code>DEFAULT_FILL_SUFFIX</code> Filename suffix for filled PDF <code>\"-filled\"</code> <code>COLOR_WHITE</code> Normalized RGB tuple for target white detection <code>(1, 1, 1)</code> <code>COLOR_BLACK</code> Normalized RGB tuple for black text filtering <code>(0, 0, 0)</code> <code>TARGET_COLOUR</code> Color targeted for detection (default is white) <code>(1, 1, 1)</code> <code>GAP</code> Minimum horizontal gap between boxes in the same block <code>1.9</code> <code>GAP_GROUP</code> Gap threshold used for grouping blocks <code>7.6</code> <code>GAP_THRESHOLD</code> Threshold for breaking blocks due to large gaps <code>3.0</code> <code>F</code> Small fudge factor for positioning adjustments <code>1</code> <code>MIN_BOX_HEIGHT</code> Minimum height of detected boxes (points) <code>15.0</code> <code>MAX_BOX_HEIGHT</code> Maximum height of detected boxes (points) <code>30.0</code> <code>NUMERIC_FIELD_TYPES</code> List of field types considered numeric <code>[\"Currency\", \"CurrencyDecimal\", \"DollarCents\", \"Dollars\"]</code> <code>PDF_PAGES</code> Global list of pages to process during a run <code>[]</code>"},{"location":"config.html#customizing-field-detection","title":"Customizing Field Detection","text":"<p>flyfield\u2019s field detection pipeline can be tuned by modifying constants or APIs:</p> <ul> <li>Height Filters Adjust <code>MIN_BOX_HEIGHT</code> and <code>MAX_BOX_HEIGHT</code> to control acceptable box sizes.</li> <li>Colour Filters Change <code>TARGET_COLOUR</code> to detect placeholders of different colours if necessary.</li> <li>Horizontal Grouping Sensitivity Modify <code>GAP</code>, <code>GAP_GROUP</code>, and <code>GAP_THRESHOLD</code> to customize grouping behaviour of detected boxes.</li> <li>Field Type Assignment Update <code>NUMERIC_FIELD_TYPES</code> to support additional or alternative numeric field types.</li> </ul>"},{"location":"config.html#csv-handling","title":"CSV Handling","text":"<ul> <li>CSV files must be UTF-8 encoded and contain structured metadata columns like <code>page_num</code>, <code>id</code>, <code>x0</code>, <code>y0</code>, etc., alongside the <code>fill</code> values.</li> <li>Numeric fields are parsed using:<ul> <li><code>parse_money_space</code></li> <li><code>parse_implied_decimal</code></li> </ul> </li> <li>Output formatting uses <code>format_money_space</code>.</li> <li>Running with the <code>--debug</code> flag writes intermediate CSV snapshots for detailed troubleshooting.</li> </ul>"},{"location":"config.html#environment-variables","title":"Environment Variables","text":"Variable Description <code>flyfield_LOG_LEVEL</code> Sets logging verbosity (<code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>) <code>flyfield_CONFIG_FILE</code> Reserved for future support for user-configured JSON/YAML files"},{"location":"config.html#example-adjust-box-height-threshold","title":"Example: Adjust Box Height Threshold","text":"<pre><code>from flyfield import config, extract\n\nconfig.MIN_BOX_HEIGHT = 12.0  # Lower minimum height\n\nboxes = extract.extract_boxes(\"example.pdf\")\n</code></pre> <p>Info</p> <ul> <li>Most users can rely solely on the CLI with default constants.</li> <li>Developers can override these settings programmatically.</li> <li>The generated Python scripts for field generation and filling remain customizable entry points.</li> </ul>"},{"location":"developer.html","title":"Developer Guide for flyfield","text":"<p>This guide provides technical details on the internal architecture of flyfield, instructions for setting up a development environment, and guidelines for contributing or customizing the project.</p>"},{"location":"developer.html#architecture-overview","title":"Architecture Overview","text":"<p>flyfield is implemented in Python and consists of the following key components:</p> <ul> <li>PDF Processing Layer Utilizes PyMuPDF for parsing PDFs and PyPDFForm for creating and manipulating interactive PDF form fields.</li> <li>Extraction Module Scans vector PDF graphics to detect white box placeholders representing form fields.</li> <li>Filtering and Grouping Logic Applies size, colour, and structural heuristics to filter out noise and cluster valid boxes into organized groups.</li> <li>Field Generation and Filling Creates interactive PDF form fields and fills them programmatically using CSV data.</li> <li>Script Generation Produces reusable standalone Python scripts to add or fill forms, allowing for advanced customization.</li> </ul>"},{"location":"developer.html#development-environment-setup","title":"Development Environment Setup","text":"<p>For safe development and testing:</p> <ul> <li>Always work with copied PDFs to avoid overwriting original documents.</li> <li>The repository contains:<ul> <li><code>flyfield/</code> \u2014 core source code</li> <li><code>tests/</code> \u2014 unit and integration tests</li> <li><code>docs/</code> \u2014 documentation files</li> </ul> </li> </ul>"},{"location":"developer.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or later</li> <li>Git for version control</li> <li>Virtual environment tools (e.g. <code>venv</code>, <code>virtualenv</code>)</li> <li>Python dependencies specified in <code>requirements.txt</code></li> </ul>"},{"location":"developer.html#installing-and-running","title":"Installing and Running","text":"<pre><code>git clone https://github.com/flywire/flyfield_docs.git\ncd flyfield_docs\npython -m venv env\nsource env/bin/activate   # or .\\env\\Scripts\\activate on Windows\npip install -r requirements.txt\n</code></pre> <p>Run tests with:</p> <pre><code>pytest\n</code></pre> <p>The test suite covers extraction, filtering, field generation, filling, and data capture workflows.</p>"},{"location":"developer.html#customization-points","title":"Customization Points","text":"<p>Areas commonly extended by developers include:</p> <ul> <li>Filtering Criteria Adjust detection parameters for box size, colour, and positioning in extraction modules.</li> <li>Field Naming Schemes Customize how field codes are assigned to match external system requirements.</li> <li>Script Templates Modify the templates for generated Python scripts to handle special layouts or behaviours.</li> </ul>"},{"location":"developer.html#contribution-guidelines","title":"Contribution Guidelines","text":"<ul> <li>Use feature branches when working on new changes.</li> <li>Adhere to PEP 8 style guidelines and include docstrings for clarity.</li> <li>Write tests for new features or bug fixes.</li> <li>Submit pull requests with descriptive titles and explanations.</li> </ul>"},{"location":"developer.html#debugging-and-logging","title":"Debugging and Logging","text":"<ul> <li>Enable verbosity with the <code>--debug</code> CLI flag for detailed logs and intermediate files.</li> <li>For development, adjust Python's logging to DEBUG level as needed.</li> </ul>"},{"location":"developer.html#resources","title":"Resources","text":"<ul> <li>API Documentation \u2014 detailed function references</li> <li>User Guide \u2014 CLI usage and workflows</li> <li>Worked Example \u2014 complete automation scenario</li> </ul> <p>Thank you for contributing to flyfield! Your efforts help improve and extend the tool.</p> <p>Happy coding and PDF automation!</p>"},{"location":"example.html","title":"Worked Example: Automating a Tax Return PDF Form","text":"<p>This detailed step-by-step example demonstrates how to use flyfield for extracting, marking up, generating form fields, filling, and capturing data from a real complex form. It starts with copying the original PDF to a new working filename to safeguard the source and uses this filename as the base for every output file in the workflow.</p>"},{"location":"example.html#prerequisites","title":"Prerequisites","text":"<p>Before following this example, you should be familiar with the Quick Start Guide.</p> <ul> <li>flyfield installed and operational</li> <li>Source PDF: Trust-tax-return-2024.pdf</li> <li>CSV file containing field codes and associated data: example-fields-filled-capture.csv</li> </ul> Take a look at the CSV contents: <pre><code>code,fill\n1-3-1,123\n1-3-2,456\n1-3-3,789\n1-4-1,GREENFIELD FAMILY TRUST\n1-6-1,12\n1-6-2,345\n1-6-3,678\n1-6-4,901\n1-9-1,45 MARKET STREET\n1-11-1,SYDNEY\n1-11-2,NSW\n1-11-3,2000\n2-4-1,DOE &amp; CO TRUSTEES PTY LTD\n2-6-1,98\n2-6-2,765\n2-6-3,432\n2-6-4,109\n2-6-5,(02) 9876 5432\n2-10-1,D\n2-15-1,62000\n2-15-2,123\n2-15-3,456\n2-15-4,789\n2-16-1,GREENFIELD FAMILY TRUST\n4-6-1,3606\n4-8-1,22870\n4-10-1,26476\n4-12-1,7069.35\n5-1-1,123\n5-1-2,456\n5-1-3,789\n5-8-1,26476\n5-17-1,26476\n6-3-1,463\n6-3-5,463\n6-4-1,15.64\n6-6-1,26939\n6-8-1,26939\n11-7-1,26939\n12-2-1,X\n12-3-1,DOE\n12-4-1,JOHN\n12-11-1,1\n12-11-2,4\n12-11-3,1945\n12-12-1,30\n12-13-1,8889\n12-25-1,1190\n12-28-1,152\n12-30-1,5.16\n12-33-1,7547\n12-35-1,2332.89\n14-2-2,X\n14-3-1,DOE\n14-4-1,JANE\n14-11-1,25\n14-11-2,12\n14-11-3,1950\n14-13-1,17779\n14-25-1,2380\n14-28-1,305\n14-30-1,10.32\n14-33-1,15094\n14-35-1,4665.77\n</code></pre> <p>Workflow Overview</p> <ol> <li>Copy the original PDF to a working filename</li> <li>Create a marked-up PDF to verify field positions</li> <li>Generate interactive form fields</li> <li>Fill form fields using CSV data</li> <li>Capture filled form data back into a CSV for editing or reuse</li> </ol>"},{"location":"example.html#step-1-copy-the-source-pdf","title":"Step 1: Copy the Source PDF","text":"<p>Begin by copying the original tax return PDF:</p> <pre><code>copy Trust-tax-return-2024.pdf example.pdf\n</code></pre> <p>Outputs:</p> <ul> <li><code>example.pdf</code> \u2014 copied working PDF file.</li> </ul> <p>This protects the integrity of the original form by avoiding accidental overwrites or corruption. It also keeps all outputs organized and traceable by using a convenient base filename <code>example.pdf</code>.</p>"},{"location":"example.html#step-2-create-markup-pdf-for-verification","title":"Step 2: Create Markup PDF for Verification","text":"<p>Create a visual markup of the fields for manual verification:</p> <pre><code>flyfield --input-pdf example.pdf --markup\n</code></pre> <p>Outputs:</p> <ul> <li><code>example-markup.pdf</code> \u2014 PDF showing detected field boxes and codes.</li> <li><code>example.csv</code> \u2014 updated field codes and metadata.</li> </ul> <p>Review this file carefully to validate the correctness and alignment of detected form fields against the original.</p>"},{"location":"example.html#step-3-generate-interactive-pdf-form-fields","title":"Step 3: Generate Interactive PDF Form Fields","text":"<p>The <code>--fields</code> option tells flyfield to detect placeholder boxes and add interactive fields.</p> <p>On long documents (e.g. 20 pages), this process can be slow.</p> <p>Important best-practice:</p> <ul> <li>Always process the full PDF to preserve consistent field codes that embed the original page number.</li> <li>Do not physically extract and save partial page PDFs before running \u2014 doing so changes the page numbering context, breaking reproducibility.</li> </ul> <p>If you want to limit processing while preserving field code consistency, use the <code>--pdf-pages</code> option. This processes only selected pages but retains original numbering.</p> <p>Example: restrict processing to pages 1, 2, 4\u20136, 11, 12, and 14:</p> <p>Run the command:</p> <pre><code>flyfield --input-pdf example.pdf --pdf-pages=\"1,2,4-6,11,12,14\" --fields\n</code></pre> <p>Outputs:</p> <ul> <li><code>example-fields.pdf</code> \u2014 PDF with interactive form fields added</li> <li><code>example-field-generator.py</code> \u2014 Python script used to generate those fields</li> <li><code>example.csv</code> \u2014 extracted field codes and metadata</li> </ul> <p>Advanced User Bonus: Editing the Python Field Generator Script</p> <p>This generated Python script can be modified to customize or unify fields, for instance to link repeated field entries across pages.</p> <p>Example: Linking the Tax File Number (TFN) fields at the top of page 5 and page 1.</p> <ol> <li>Open <code>example-field-generator.py</code> in a text editor</li> <li>Locate the code block that defines fields at the top of page 5</li> <li>Change each field name in that section from something like<code>\"5-1-1\"</code>to reference the page 1 TFN field names, e.g., <code>\"1-3-1\"</code>, <code>\"1-3-2\"</code>, <code>\"1-3-3\"</code></li> <li>Save your changes</li> <li>Regenerate the filled PDF by running: <pre><code>python example-field-generator.py\n</code></pre></li> </ol> <p>This rebuilds <code>example-fields.pdf</code> with linked fields, so entering the TFN once will automatically update it on both pages.</p>"},{"location":"example.html#step-4-fill-form-fields-with-csv-data","title":"Step 4: Fill Form Fields With CSV Data","text":"<p>After confirming fields, supply a CSV file containing at least two columns, <code>code</code> and <code>fill</code>, to fill the interactive form fields with your CSV data:</p> <pre><code>flyfield --input-pdf example-fields.pdf --fill example-fields-filled-capture.csv\n</code></pre> <p>Outputs:</p> <ul> <li><code>example-fields-filled.pdf</code> \u2014 filled PDF form with CSV data inserted</li> <li><code>example-fields-filler.py</code> \u2014 Python script used to perform filling (editable for customization)</li> </ul>"},{"location":"example.html#step-5-capture-data-from-filled-form","title":"Step 5: Capture Data From Filled Form","text":"<p>Capture the filled form data back into a CSV file for review or reuse:</p> <pre><code>flyfield --input-pdf example-fields-filled.pdf --capture\n</code></pre> <p>Outputs:</p> <ul> <li><code>example-fields-filled-capture.csv</code> \u2014 extracted form data, which can be edited and reused.</li> </ul> <p>Demonstrated</p> <ul> <li>Working safely with a copy of the original PDF to protect the source</li> <li>Validating detected form fields visually by generating a markup PDF</li> <li>Improving efficiency by generating fields only on required pages</li> <li>Tailoring workflows by direct editing and rerunning the generated Python field generation script</li> <li>Managing data consistency by reusing CSV data for filling and capturing</li> </ul> <p>This example provides a practical, real-world automation workflow for PDF form processing using flyfield. It assumes basic familiarity covered by the Quick Start Guide, guiding users through safely and effectively managing complex tax return forms.</p>"},{"location":"faq.html","title":"Frequently Asked Questions (FAQ)","text":"<p>This section addresses common questions and provides troubleshooting tips for flyfield users.</p>"},{"location":"faq.html#installation-issues","title":"Installation Issues","text":""},{"location":"faq.html#q-i-installed-flyfield-using-pipx-but-the-command-is-not-recognized-what-should-i-do","title":"Q: I installed flyfield using pipx, but the command is not recognized. What should I do?","text":"<p>A: This usually happens if the pipx install directory is not in your system's PATH environment variable. To fix:</p> <ol> <li> <p>Run the command: <pre><code>pipx ensurepath\n</code></pre></p> </li> <li> <p>Restart your terminal or command prompt.</p> </li> <li>Verify by running: <pre><code>flyfield --help\n</code></pre></li> </ol> <p>Ensure you run the command in the same user context where pipx was installed.</p>"},{"location":"faq.html#usage-workflow","title":"Usage &amp; Workflow","text":""},{"location":"faq.html#q-how-can-i-check-which-version-of-flyfield-i-have-installed","title":"Q: How can I check which version of flyfield I have installed?","text":"<p>A: Use the command:</p> <pre><code>flyfield --version\n</code></pre> <p>This prints the installed version.</p>"},{"location":"faq.html#q-how-do-i-speed-up-processing-on-large-pdfs","title":"Q: How do I speed up processing on large PDFs?","text":"<p>A: The <code>--fields</code> step (field generation) can be slow. Best practices:</p> <ul> <li>Run <code>--fields</code> only once per PDF version.</li> <li>Reuse cached CSV and markup PDF files for subsequent steps.</li> </ul>"},{"location":"faq.html#q-my-field-codes-are-inconsistent-when-extracting-from-a-subset-of-pages-why","title":"Q: My field codes are inconsistent when extracting from a subset of pages. Why?","text":"<p>A: Field codes embed page number context. Always run extraction on the full PDF to maintain consistent codes. Use <code>--pdf-pages</code> to limit processing without renumbering.</p>"},{"location":"faq.html#q-do-i-need-to-run-a-separate-extraction-step-before-generating-fields","title":"Q: Do I need to run a separate extraction step before generating fields?","text":"<p>A: No, extraction runs automatically unless you provide <code>--input-csv</code>, which skips it.</p>"},{"location":"faq.html#q-why-are-some-expected-fields-missing-from-markup-output","title":"Q: Why are some expected fields missing from markup output?","text":"<p>A: flyfield detects only pure white vector boxes within configured size ranges.</p> <p>Possible causes for missing fields:</p> <ul> <li>Boxes are shaded, colored, or not pure white.</li> <li>The PDF is raster/scanned rather than vector.</li> <li>Boxes outside height thresholds.</li> </ul> <p>Use <code>--debug</code> to examine intermediate CSV files.</p>"},{"location":"faq.html#q-why-should-i-always-use-a-copy-of-the-original-pdf-before-processing","title":"Q: Why should I always use a copy of the original PDF before processing?","text":"<p>A: flyfield modifies PDFs by creating output files with appended suffixes. Using copies prevents accidental overwrites of original documents.</p>"},{"location":"faq.html#q-why-capture-data-from-filled-pdfs-what-if-the-form-changes-yearly","title":"Q: Why capture data from filled PDFs? What if the form changes yearly?","text":"<p>A: Many fields remain stable across versions. Captured data helps:</p> <ul> <li>Reuse unchanged data.</li> <li>Reduce manual entry errors.</li> <li>Support audits and comparisons over time.</li> </ul> <p>Remapping may be required if form layout changes significantly.</p>"},{"location":"faq.html#advanced-customization","title":"Advanced Customization","text":""},{"location":"faq.html#q-can-i-customize-field-naming-or-positioning","title":"Q: Can I customize field naming or positioning?","text":"<p>A: Yes. flyfield generates standalone Python scripts for:</p> <ul> <li>Adding fields (<code>*-field-generator.py</code>)</li> <li>Filling fields (<code>*-filler.py</code>)</li> </ul> <p>You can edit these scripts to customize names, coordinates, max lengths, and formatting.</p> <p>Run the modified scripts to regenerate PDFs or refill data.</p>"},{"location":"faq.html#troubleshooting","title":"Troubleshooting","text":""},{"location":"faq.html#q-why-do-filled-fields-not-show-up-correctly-in-some-pdf-viewers","title":"Q: Why do filled fields not show up correctly in some PDF viewers?","text":"<p>A: PDF viewer compatibility varies. To improve results:</p> <ul> <li>Use Adobe Acrobat or well-supported viewers.</li> <li>Avoid PDFs with complex overlays or security restrictions.</li> <li>Flatten fields with external tools if necessary.</li> </ul>"},{"location":"faq.html#q-how-can-i-extract-data-from-a-filled-pdf","title":"Q: How can I extract data from a filled PDF?","text":"<p>A: Use the <code>--capture</code> option:</p> <pre><code>flyfield --input-pdf filled.pdf --capture\n</code></pre> <p>This exports filled fields to CSV, normalizing numeric values and uppercasing text.</p>"},{"location":"faq.html#general-information","title":"General Information","text":""},{"location":"faq.html#q-does-flyfield-support-scanned-pdfs","title":"Q: Does flyfield support scanned PDFs?","text":"<p>A: No. flyfield requires vector PDF files with proper vector graphics and white boxes.</p>"},{"location":"faq.html#q-can-flyfield-handle-pdfs-with-existing-acroforms","title":"Q: Can flyfield handle PDFs with existing AcroForms?","text":"<p>A: flyfield detects white box placeholders in vector PDFs to generate aligned interactive form fields. While existing AcroForm fields can be filled directly using tools like PyPDFForm, flyfield might be useful for handling split numeric fields (e.g., money boxes), enabling accurate grouping and filling of these complex fields.</p> <p>For more help, consult the User Guide, Developer Guide, or Worked Example.</p>"},{"location":"glossary.html","title":"Glossary of Terms for flyfield","text":"<p>This glossary defines key terms and concepts used throughout the flyfield documentation and tooling.</p>"},{"location":"glossary.html#key-terms","title":"Key Terms","text":"<p>AcroForm A PDF specification introduced in PDF version 1.2 that enables interactive forms within PDF documents. Forms created with AcroForm include elements such as text fields, checkboxes, and buttons.</p> <p>Field (Form Field) An interactive area in a PDF where users can input or select data, such as text boxes, checkboxes, radio buttons, and dropdown menus.</p> <p>Field Code A unique identifier automatically generated by flyfield for each detected white box placeholder in a PDF. It is used to map form fields to CSV data.</p> <p>Filled PDF A PDF form that has been completed with data, either manually by a user or automatically using flyfield's filling scripts.</p> <p>Interactive Field A form field in a PDF that users can modify and interact with, either within PDF viewers or programmatically.</p> <p>Markup PDF A PDF generated by flyfield that visually annotates detected white box placeholders with boundary boxes and field codes to assist verification.</p> <p>Placeholder Box (White Box) A rectangular area in a vector PDF identified as a placeholder for data input. flyfield detects these based on fill colour and size thresholds\u2014commonly white boxes.</p> <p>Working Copy PDF A duplicate of the original PDF used as a safe working file for detection, form field generation, filling, and data capture steps.</p> <p>PyMuPDF An open-source Python library used by flyfield to parse and manipulate PDFs, extract graphical elements, and perform coordinate transformations.</p> <p>PyPDFForm A Python library employed by flyfield to create, edit, and fill interactive form fields in PDFs.</p> <p>Raster PDF A PDF consisting primarily of scanned images or bitmap graphics rather than vector objects. flyfield does not support raster PDFs for form field detection.</p> <p>Vector PDF A PDF composed of vector graphics including shapes and lines. flyfield supports vector PDFs to detect and generate form fields accurately.</p>"},{"location":"glossary.html#common-terms","title":"Common Terms","text":"<p>BBox (Bounding Box) The rectangular boundary defining the position and size of an element (such as a form field or graphic) in PDF coordinate space.</p> <p>CSV (Comma-Separated Values) A plain text format used to exchange tabular data, including field codes and input values, between flyfield workflows and external tools.</p> <p>Field Generator Script A standalone Python script created by flyfield that adds interactive form fields into PDFs based on detected white box placeholders.</p> <p>Field Filler Script A standalone Python script generated by flyfield to programmatically fill interactive form fields in PDFs using CSV data.</p>"},{"location":"glossary.html#accessibility-terms","title":"Accessibility Terms","text":"<p>Tab Order The sequence in which form fields receive keyboard focus when navigating through a PDF form, important for usability and assistive technologies.</p> <p>Screen Reader Software that reads the content of documents aloud for users with visual impairments; relies on properly tagged and labelled form fields.</p>"},{"location":"glossary.html#related-concepts","title":"Related Concepts","text":"<p>AcroForm vs XFA There are two prominent PDF form technologies. AcroForm is the widely supported standard for interactive fields and is used by flyfield. XFA (XML Forms Architecture) is an older format that is less portable and often unsupported. flyfield converts documents relying on white box placeholders, including those with XFA templates, into modern AcroForm-based workflows by detecting placeholders and generating corresponding fields.</p>"},{"location":"installation.html","title":"Installation Guide for flyfield","text":"<p>This guide provides detailed instructions to install and prepare flyfield on your system.</p>"},{"location":"installation.html#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.9 or later installed</li> <li>Access to a command-line interface (Command Prompt, PowerShell, or Terminal)</li> </ul>"},{"location":"installation.html#installation-methods","title":"Installation Methods","text":""},{"location":"installation.html#1-recommended-install-via-pipx","title":"1. Recommended: Install via pipx","text":"<p><code>pipx</code> installs Python CLI programs in isolated environments and avoids dependency conflicts.</p> <p>To install flyfield:</p> <pre><code>pipx install flyfield\n</code></pre> <p>After installation, verify it works:</p> <pre><code>flyfield --version\n</code></pre> <p>You should see the installed version number.</p>"},{"location":"installation.html#2-alternative-install-via-pip-in-a-virtual-environment","title":"2. Alternative: Install via pip in a Virtual Environment","text":"<ol> <li> <p>Create and activate a virtual environment:</p> </li> <li> <p>On macOS/Linux:</p> </li> </ol> <pre><code>python3 -m venv env\nsource env/bin/activate\n</code></pre> <ul> <li>On Windows:</li> </ul> <pre><code>python -m venv env\n.\\env\\Scripts\\activate\n</code></pre> <ol> <li> <p>Install flyfield: <pre><code>pip install flyfield\n</code></pre></p> </li> <li> <p>Verify installation: <pre><code>flyfield --version\n</code></pre></p> </li> </ol>"},{"location":"installation.html#development-installation-for-contributors","title":"Development Installation (for contributors)","text":"<p>For contributors or advanced users wanting editable installs:</p> <ol> <li> <p>Clone the repository: <pre><code>git clone https://github.com/flywire/flyfield_docs.git\ncd flyfield_docs\n</code></pre></p> </li> <li> <p>Install with dev dependencies: <pre><code>pip install -e .[dev]\n</code></pre></p> </li> <li> <p>Run the test suite: <pre><code>pytest\n</code></pre></p> </li> </ol>"},{"location":"installation.html#troubleshooting","title":"Troubleshooting","text":"<ul> <li>flyfield command not found after pipx install Run:</li> </ul> <pre><code>pipx ensurepath\n</code></pre> <p>Then restart your terminal. - Permission errors on pip install Use:</p> <pre><code>pip install --user flyfield\n</code></pre> <ul> <li>Old pip version causes issues Upgrade pip:</li> </ul> <pre><code>pip install --upgrade pip\n</code></pre> <ul> <li>Dependencies required flyfield depends on:<ul> <li>PyMuPDF for parsing and extraction</li> <li>PyPDFForm for adding interactive form fields</li> </ul> </li> </ul>"},{"location":"introduction.html","title":"Introduction to flyfield","text":"<p>Welcome to the flyfield documentation! flyfield is a Python toolset that automates the creation, filling, and data extraction of interactive PDF forms built around white box placeholders.</p>"},{"location":"introduction.html#what-is-flyfield","title":"What is flyfield?","text":"<p>flyfield offers both a Python library and a command-line interface (CLI) designed to automate workflows involving:</p> <ul> <li>Detecting and extracting white rectangular placeholders in vector PDFs</li> <li>Generating interactive form fields aligned to those placeholders</li> <li>Filling PDF forms programmatically using CSV data</li> <li>Capturing filled form data back into CSV for editing or reuse</li> </ul> <p>The goal is to simplify converting paper-style forms into machine-readable automated workflows, reducing repetitive manual entry.</p>"},{"location":"introduction.html#who-is-it-for","title":"Who is it for?","text":"<p>flyfield is intended for anyone who needs to automate PDF form workflows involving standard white box placeholders, including:</p> <ul> <li>Users aiming to reduce repetitive manual data entry and improve accuracy</li> <li>Professionals integrating PDF form automation into software and systems</li> <li>Operators connecting PDF forms seamlessly with spreadsheets or databases</li> <li>Teams automating workflows involving administrative, financial, or tax-intensive forms</li> </ul>"},{"location":"introduction.html#why-use-flyfield","title":"Why use flyfield?","text":"<ul> <li>Automates data entry \u2014 Detect, fill, and export form fields with no manual typing</li> <li>Increases accuracy \u2014 CSV integration reduces common errors</li> <li>Streamlines workflows \u2014 Batch processing and reusable scripts save time on large form sets</li> <li>Extensible \u2014 Generated Python scripts can be customized for advanced use</li> </ul>"},{"location":"introduction.html#key-features","title":"Key Features","text":"<ul> <li>Automatic detection and extraction of white boxes (no separate extraction needed unless CSV is provided)</li> <li>Visual markup PDFs for validation before filling</li> <li>Script generation for reproducible form creation and filling</li> <li>CSV-based exchange for easy integration with spreadsheets, databases, and downstream systems</li> </ul>"},{"location":"introduction.html#how-to-use-this-documentation","title":"How to use this documentation","text":"<ul> <li>Start with the Quick Start Guide for setup and essential commands</li> <li>Follow the Worked Example for a comprehensive end-to-end scenario</li> <li>Consult the User Guide for detailed CLI instructions</li> <li>Review the API Documentation for programmatic usage</li> <li>Check the FAQ for common questions and issues</li> <li>Explore the Developer Guide for internal architecture and contribution guidance</li> </ul> <p>We hope flyfield helps simplify your PDF form workflows and saves you time.</p> <p>Happy automating!</p>"},{"location":"process.html","title":"Processing Workflow of flyfield","text":"<p>This document provides a detailed overview of the multi-stage processing pipeline flyfield uses to detect, generate, fill, and capture PDF form fields based on white box placeholders.</p>"},{"location":"process.html#workflow-diagram","title":"Workflow Diagram","text":"<pre><code>---\nconfig:\n  theme: default\n  look: handDrawn\n  layout: elk\n---\nflowchart TD\n    Start([Start CLI]) --&gt; ParseArgs[\"Parse CLI Arguments\"]\n    ParseArgs --&gt; CheckPDF{\"PDF file exists?\"}\n    CheckPDF -- Yes --&gt; LoadCSV{\"--input-csv provided?\"}\n    CheckPDF -- No --&gt; Fatal1[Exit with error]\n\n    LoadCSV -- Yes --&gt; LoadBoxes[\"load boxes from csv\"]\n        LoadBoxes --&gt; ActionChoice\n        LoadBoxes -. Fail .-&gt; Fatal2[Exit with error]\n\n    LoadCSV -- No --&gt; ProcessBoxes[\"process boxes\"]\n\n    ProcessBoxes --&gt; ActionChoice\n\n    ActionChoice{\"Perform actions:\"}\n    ActionChoice --&gt;|--markup| DoMarkup[\"markup pdf \u2192 -markup.pdf\"]\n    ActionChoice --&gt;|--fields| DoFields[\"generate form fields script \u2192 run standalone script \u2192 -fields.pdf\"]\n    ActionChoice --&gt;|--fill FILE| DoFill[\"run fill pdf fields \u2192 -filled.pdf\"]\n    ActionChoice --&gt;|--capture| DoCapture[\"save pdf form data to csv \u2192 -capture.csv\"]\n\n    DoMarkup --&gt; Next[Continue with updated input pdf]\n    DoFields --&gt; Next\n    DoFill --&gt; Next\n    DoCapture --&gt; Next\n    Next --&gt; End([End])\n</code></pre>"},{"location":"process.html#workflow-overview","title":"Workflow Overview","text":"<p>flyfield automates converting static white box placeholders in PDFs into interactive, fillable forms through these stages:</p> <ol> <li>Extraction of White Boxes Identifies candidate white rectangular boxes in the PDF.</li> <li>Filtering, Deduplication, and Sorting Removes irrelevant boxes, merges duplicates, and orders them for processing.</li> <li>Layout Annotation &amp; Numeric Assignment Groups boxes into logical blocks, labels with codes, and detects numeric field patterns.</li> <li>Field Generation &amp; Markup Creates interactive PDF fields aligned to detected placeholders and optionally adds visual markup for verification.</li> <li>Filling PDF Fields Uses CSV data to programmatically populate fields with values.</li> <li>Data Capture from Filled Forms Extracts filled field values back into CSV for reuse or analysis.</li> </ol> <p>Each phase is implemented in separate Python modules allowing flexible scripting and customization.</p>"},{"location":"process.html#detailed-steps","title":"Detailed Steps","text":""},{"location":"process.html#1-extraction-of-white-boxes","title":"1. Extraction of White Boxes","text":"<ul> <li>Module: <code>flyfield.extract.extract_boxes</code></li> <li>Scans the PDF via PyMuPDF to locate filled white rectangles matching the target color (default RGB white <code>(1,1,1)</code>), considering only vector content.</li> <li>Converts coordinates from PyMuPDF's origin (top-left) to PDF standard origin (bottom-left).</li> <li>Extracted data includes page number, bounding box coordinates, text overlays, and fill colors.</li> <li>Outputs a raw CSV snapshot when run with the <code>--debug</code> flag, listing all candidate boxes.</li> </ul>"},{"location":"process.html#2-filtering-deduplication-and-sorting","title":"2. Filtering, Deduplication, and Sorting","text":"<ul> <li>Module: <code>flyfield.extract</code></li> <li>Applies height thresholds (<code>MIN_BOX_HEIGHT</code> and <code>MAX_BOX_HEIGHT</code>) to filter box sizes.</li> <li>Uses content-based heuristics to exclude boxes with disallowed or pre-printed text.</li> <li>Removes duplicate entries by comparing rounded box coordinates.</li> <li>Sorts remaining boxes by page, top-to-bottom, then left-to-right order.</li> <li>Writes intermediate CSV files for grouping and filtering steps if debugging is enabled.</li> </ul>"},{"location":"process.html#3-layout-annotation-numeric-assignment","title":"3. Layout Annotation &amp; Numeric Assignment","text":"<ul> <li>Module: <code>flyfield.layout</code></li> <li>Assigns unique IDs to boxes in the format <code>{page}-{line}-{block}</code>, representing logical grouping within pages and rows.</li> <li>Groups horizontally aligned boxes into blocks based on configured gap thresholds.</li> <li>Calculates block dimensions and concatenates overlay text.</li> <li>Applies numeric field recognition rules to merge multi-block numeric patterns (e.g., monetary amounts split into multiple boxes) and assign types such as <code>\"Currency\"</code> or <code>\"CurrencyDecimal\"</code>.</li> <li>Writes a detailed layout CSV for validation and debugging.</li> </ul>"},{"location":"process.html#4-field-generation-markup","title":"4. Field Generation &amp; Markup","text":"<ul> <li>Module: <code>flyfield.markup_and_fields</code></li> <li>Generates a standalone Python script that, when run, adds interactive AcroForm text fields positioned and sized according to box annotations.</li> <li>Runs the generation script automatically to create a new PDF with enabled form fields.</li> <li>Optionally, creates a markup PDF that overlays visual elements such as circles around boxes, rendered field codes rotated at 45\u00b0, facilitating human verification of detection accuracy.</li> </ul>"},{"location":"process.html#5-filling-pdf-fields","title":"5. Filling PDF Fields","text":"<ul> <li>Module: <code>flyfield.markup_and_fields.run_fill_pdf_fields</code></li> <li>Generates and executes a Python script to fill interactive form fields using a CSV file mapping field codes to fill values.</li> <li>Skips entries with empty or zero values to avoid overwriting.</li> <li>Parses currency and numeric fields, normalizing inputs by removing formatting as required.</li> <li>Produces a filled PDF annotated with entered data.</li> <li>Logs script output to assist with troubleshooting.</li> </ul>"},{"location":"process.html#6-data-capture-from-filled-forms","title":"6. Data Capture from Filled Forms","text":"<ul> <li>Module: <code>flyfield.io_utils.save_pdf_form_data_to_csv</code></li> <li>Reads completed interactive forms via PyPDFForm.</li> <li>Extracts field values, coercing numeric types based on configured rules, and normalizes text (e.g., uppercase).</li> <li>Outputs a CSV aligned with original field codes to facilitate downstream processing, data review, or iterative filling.</li> </ul> <p>Additional Notes</p> <ul> <li>Only vector PDFs with clear white boxes are supported; scanned or rasterized PDFs are not compatible.</li> <li>Large PDFs may take longer during field generation (<code>--fields</code>), so it is recommended to run this step sparingly and cache outputs.</li> <li>Debug mode (<code>--debug</code>) generates helpful intermediate CSVs for each processing stage, improving traceability and aiding issue diagnosis.</li> <li>All generated scripts are standalone and can be customized for advanced workflows or integration into automated pipelines.</li> </ul>"},{"location":"quick_start.html","title":"Quick Start Guide","text":"<p>This quick start guide helps you get up and running with flyfield efficiently.</p>"},{"location":"quick_start.html#what-you-need-prerequisites","title":"What You Need (Prerequisites)","text":"<p>Before you begin using flyfield, you need the following:</p> <ul> <li>Familiarity with Command Line</li> </ul> <p>You should know how to open and use the terminal (Linux/macOS) or command prompt/PowerShell (Windows) to run commands. This is necessary to execute flyfield commands properly.</p> <ul> <li>Python Installation</li> </ul> <p>flyfield requires Python 3.9 or later. To check your Python version, open a terminal or command prompt and run:</p> <pre><code>python --version\n</code></pre> <p>If Python is not installed or if the version is below 3.9, download and install the latest Python version from python.org. Follow the installer instructions suitable for your operating system.</p> <ul> <li>Installing flyfield</li> </ul> <p>The recommended method to install flyfield is using <code>pipx</code>, which allows you to install and run Python CLI tools in isolated environments. To install pipx (if you don't have it), run:</p> <pre><code>python -m pip install --user pipx\npython -m pipx ensurepath\n</code></pre> <p>Once pipx is installed, install flyfield by running:</p> <pre><code>pipx install flyfield\n</code></pre> <p>After installation, verify that flyfield is correctly installed by running:</p> <pre><code>flyfield --version\n</code></pre> <p>This should print the installed version number without errors.</p> <ul> <li>PDF and Data Files Have a copy of the PDF form you want to automate, for example:</li> </ul> <pre><code>Trust-tax-return-2024.pdf\n</code></pre> <p>Also prepare or obtain a CSV file containing your field codes and corresponding values in a <code>code,fill</code> column format, for example:</p> <pre><code>example-fields-filled-capture.csv\n</code></pre> <p>Typical Workflow Overview</p> <ol> <li>Make a copy of your original PDF (keep it safe)</li> <li>Generate a markup PDF that shows detected field boxes to verify visually</li> <li>Extract and generate interactive form fields on selected pages</li> <li>Fill the PDF fields using data from your CSV file</li> <li>Capture filled form data back into CSV for review or reuse</li> </ol> <p>Useful Tips</p> <ul> <li>Ensure your CSV files are UTF-8 encoded and properly formatted</li> <li>Use the <code>--debug</code> flag for more detailed logs if encountering issues</li> </ul>"},{"location":"quick_start.html#want-more","title":"Want More?","text":"<p>For a detailed, step-by-step walkthrough with real-world examples and commands, see the Worked Example.</p> <p>This streamlined guide gives you the essentials to start using flyfield safely and confidently, pointing to deeper tutorial content for extended learning.</p>"},{"location":"usage.html","title":"User Guide and CLI Reference","text":"<p>This guide details the command-line interface (CLI) options and typical workflows for using flyfield effectively.</p>"},{"location":"usage.html#cli-basic-structure","title":"CLI Basic Structure","text":"<p>Run flyfield commands with the following general syntax:</p> <pre><code>flyfield [options]\n</code></pre>"},{"location":"usage.html#common-command-line-options","title":"Common Command-Line Options","text":"Option Description <code>--version</code> Show the installed flyfield version and exit <code>--input-pdf FILE</code> Specify the input PDF filename to process <code>--pdf-pages PAGES</code> Select pages to process, e .g., <code>\"1,3-5,7\"</code> <code>--input-csv FILE</code> Specify a CSV file with field data, skipping extraction <code>--markup</code> Generate a markup PDF showing detected fields and codes <code>--fields</code> Generate interactive form fields on the PDF <code>--fill FILE</code> Fill form fields using values from the specified CSV file <code>--capture</code> Extract filled form data back into a CSV <code>--debug</code> Enable verbose debug outputs for troubleshooting <code>-h</code>, <code>--help</code> Show help message and exit"},{"location":"usage.html#typical-workflow-examples","title":"Typical Workflow Examples","text":""},{"location":"usage.html#generate-fields-and-extract-data","title":"Generate Fields and Extract Data","text":"<p>If you have no CSV, flyfield automatically detects white box placeholders and generates fields.</p> <pre><code>flyfield --input-pdf form.pdf --fields\n</code></pre> <p>Produces:</p> <ul> <li><code>form-fields.pdf</code> \u2014 PDF with interactive fields added.</li> <li><code>form-fields.csv</code> \u2014 CSV of detected fields and positions.</li> <li><code>form-field-generator.py</code> \u2014 Script used for field generation.</li> </ul>"},{"location":"usage.html#create-markup-for-verification","title":"Create Markup for Verification","text":"<p>Generate an annotated PDF showing detected boxes, aiding manual verification:</p> <pre><code>flyfield --input-pdf form.pdf --markup\n</code></pre>"},{"location":"usage.html#fill-form-fields-with-csv-data","title":"Fill Form Fields with CSV Data","text":"<p>Populate form fields from a CSV file containing mappings of codes to values:</p> <pre><code>flyfield --input-pdf form-fields.pdf --fill data.csv\n</code></pre>"},{"location":"usage.html#capture-filled-form-data","title":"Capture Filled Form Data","text":"<p>Export filled data to CSV, enabling review or re-use:</p> <pre><code>flyfield --input-pdf filled-form.pdf --capture\n</code></pre>"},{"location":"usage.html#combining-options","title":"Combining Options","text":"<p>You can combine multiple options, for example:</p> <pre><code>flyfield --input-pdf form.pdf --markup --fields\n</code></pre> <p>Note: The <code>--fields</code> step may be slow on large PDFs; reuse cached results when possible.</p>"},{"location":"usage.html#customizing-generated-scripts","title":"Customizing Generated Scripts","text":"<p>Generated Python scripts (<code>field-generator.py</code> and <code>filler.py</code>) are editable:</p> <ul> <li>Modify field naming, placement, or attributes.</li> <li>Apply custom formatting or logic.</li> <li>Rerun scripts manually to apply changes.</li> </ul> <p>Tips and Troubleshooting</p> <ul> <li>Always work on a copy of the original PDF to prevent data loss.</li> <li>Save time by avoiding redundant extraction; reuse CSVs and PDFs.</li> <li>Use <code>--debug</code> to produce detailed logs and CSV snapshots.</li> <li>flyfield supports only vector PDFs with clear white box placeholders.</li> <li>Ensure CSV files are UTF-8 encoded and contain at least two columns: <code>code</code> and <code>fill</code>.</li> </ul> <p>For additional guidance, see:</p> <ul> <li>Quick Start Guide</li> <li>Worked Example</li> </ul> <p>This guide empowers users to utilize flyfield\u2019s CLI for reliable automated PDF form workflows.</p>"}]}